<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>xyginext: xy::NetClient Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">xyginext
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
   <div id="projectbrief">Second generation of xygine game creation framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacexy.html">xy</a></li><li class="navelem"><a class="el" href="classxy_1_1_net_client.html">NetClient</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classxy_1_1_net_client-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">xy::NetClient Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Creates a clientside host which can be used to create a peer connected to a <a class="el" href="classxy_1_1_net_host.html" title="Creates a network host. Network hosts, or servers, can have multiple clients connected to them,...">NetHost</a> server.  
 <a href="classxy_1_1_net_client.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_net_client_8hpp_source.html">NetClient.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aedae4a4a0872701646c6c6783fe51b09"><td class="memItemLeft" align="right" valign="top"><a id="aedae4a4a0872701646c6c6783fe51b09"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NetClient</b> (const <a class="el" href="classxy_1_1_net_client.html">NetClient</a> &amp;)=delete</td></tr>
<tr class="separator:aedae4a4a0872701646c6c6783fe51b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2aa429ffcb34d439d804f56822d4b04"><td class="memItemLeft" align="right" valign="top"><a id="ac2aa429ffcb34d439d804f56822d4b04"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NetClient</b> (<a class="el" href="classxy_1_1_net_client.html">NetClient</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ac2aa429ffcb34d439d804f56822d4b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d092e0f824684b016d1c162691a3a7"><td class="memItemLeft" align="right" valign="top"><a id="a93d092e0f824684b016d1c162691a3a7"></a>
<a class="el" href="classxy_1_1_net_client.html">NetClient</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classxy_1_1_net_client.html">NetClient</a> &amp;)=delete</td></tr>
<tr class="separator:a93d092e0f824684b016d1c162691a3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651c46d348535799ba1a319c3a89b77b"><td class="memItemLeft" align="right" valign="top"><a id="a651c46d348535799ba1a319c3a89b77b"></a>
<a class="el" href="classxy_1_1_net_client.html">NetClient</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classxy_1_1_net_client.html">NetClient</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a651c46d348535799ba1a319c3a89b77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d640be1f2c864fae2ae4432280180bb"><td class="memTemplParams" colspan="2">template&lt;typename T  = EnetClientImpl&gt; </td></tr>
<tr class="memitem:a4d640be1f2c864fae2ae4432280180bb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxy_1_1_net_client.html#a4d640be1f2c864fae2ae4432280180bb">create</a> (std::size_t maxChannels, std::size_t maxClients=1, sf::Uint32 incoming=0, sf::Uint32 outgoing=0)</td></tr>
<tr class="separator:a4d640be1f2c864fae2ae4432280180bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d253a6d4cba15bb64a68f5c2cd9611"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_net_client.html#aa1d253a6d4cba15bb64a68f5c2cd9611">connect</a> (const std::string &amp;address, sf::Uint16 port, sf::Uint32 timeout=5000)</td></tr>
<tr class="memdesc:aa1d253a6d4cba15bb64a68f5c2cd9611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to connect to a server on the given IPv4 address or host name.  <a href="classxy_1_1_net_client.html#aa1d253a6d4cba15bb64a68f5c2cd9611">More...</a><br /></td></tr>
<tr class="separator:aa1d253a6d4cba15bb64a68f5c2cd9611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5875d65c6428d6e54b72e19e46790c8"><td class="memItemLeft" align="right" valign="top"><a id="ae5875d65c6428d6e54b72e19e46790c8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_net_client.html#ae5875d65c6428d6e54b72e19e46790c8">connected</a> () const</td></tr>
<tr class="memdesc:ae5875d65c6428d6e54b72e19e46790c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if connected to a <a class="el" href="classxy_1_1_net_host.html" title="Creates a network host. Network hosts, or servers, can have multiple clients connected to them,...">NetHost</a> and is ready to poll for events else returns false. <br /></td></tr>
<tr class="separator:ae5875d65c6428d6e54b72e19e46790c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121474246bc4e522f1410f37c6ebc8bb"><td class="memItemLeft" align="right" valign="top"><a id="a121474246bc4e522f1410f37c6ebc8bb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_net_client.html#a121474246bc4e522f1410f37c6ebc8bb">disconnect</a> ()</td></tr>
<tr class="memdesc:a121474246bc4e522f1410f37c6ebc8bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes any active connections. This is blocking for up to 3 seconds while waiting for graceful disconnection before forcefully closing the connection and causing a timeout on the remote server. <br /></td></tr>
<tr class="separator:a121474246bc4e522f1410f37c6ebc8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dea35c53f26c797cee6a53d29654313"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_net_client.html#a3dea35c53f26c797cee6a53d29654313">pollEvent</a> (<a class="el" href="structxy_1_1_net_event.html">NetEvent</a> &amp;)</td></tr>
<tr class="memdesc:a3dea35c53f26c797cee6a53d29654313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polls the connection for events. This must be called at least once per frame to make sure all received packets are parsed and pending data is sent. Any data received is placed in the given event object. Make sure this happens on both ends of the connection (<a class="el" href="classxy_1_1_net_host.html" title="Creates a network host. Network hosts, or servers, can have multiple clients connected to them,...">NetHost</a> and <a class="el" href="classxy_1_1_net_client.html" title="Creates a clientside host which can be used to create a peer connected to a NetHost server.">NetClient</a>)  <a href="classxy_1_1_net_client.html#a3dea35c53f26c797cee6a53d29654313">More...</a><br /></td></tr>
<tr class="separator:a3dea35c53f26c797cee6a53d29654313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1bb851b6ebf91a77a1e20d05da508f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8a1bb851b6ebf91a77a1e20d05da508f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxy_1_1_net_client.html#a8a1bb851b6ebf91a77a1e20d05da508f">sendPacket</a> (std::uint8_t id, const T &amp;data, <a class="el" href="namespacexy.html#a05dcce851ad31fdc5bf3179c20b19437">NetFlag</a> flags, sf::Uint8 channel=0)</td></tr>
<tr class="memdesc:a8a1bb851b6ebf91a77a1e20d05da508f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a packet to the server if a connection is established, else does nothing. NOTE: Packets are actually queued and not sent over the connection until the next time <a class="el" href="classxy_1_1_net_client.html#a3dea35c53f26c797cee6a53d29654313" title="Polls the connection for events. This must be called at least once per frame to make sure all receive...">pollEvent()</a> is called.  <a href="classxy_1_1_net_client.html#a8a1bb851b6ebf91a77a1e20d05da508f">More...</a><br /></td></tr>
<tr class="separator:a8a1bb851b6ebf91a77a1e20d05da508f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638a42119bcaff2dae0866ab51cb6812"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_net_client.html#a638a42119bcaff2dae0866ab51cb6812">sendPacket</a> (std::uint8_t id, const void *data, std::size_t size, <a class="el" href="namespacexy.html#a05dcce851ad31fdc5bf3179c20b19437">NetFlag</a> flags, sf::Uint8 channel=0)</td></tr>
<tr class="memdesc:a638a42119bcaff2dae0866ab51cb6812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the given array of bytes out over the connection if it is active, else does nothing. Use this for pre-serialised data.  <a href="classxy_1_1_net_client.html#a638a42119bcaff2dae0866ab51cb6812">More...</a><br /></td></tr>
<tr class="separator:a638a42119bcaff2dae0866ab51cb6812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4930f66ef82e3aca6909a885e7c372"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structxy_1_1_net_peer.html">NetPeer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_net_client.html#abe4930f66ef82e3aca6909a885e7c372">getPeer</a> () const</td></tr>
<tr class="memdesc:abe4930f66ef82e3aca6909a885e7c372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the client's peer. Peers are only valid when connected to a server.  <a href="classxy_1_1_net_client.html#abe4930f66ef82e3aca6909a885e7c372">More...</a><br /></td></tr>
<tr class="separator:abe4930f66ef82e3aca6909a885e7c372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92e46a360736c1c6c5f4a55aad9e264"><td class="memItemLeft" align="right" valign="top"><a id="ab92e46a360736c1c6c5f4a55aad9e264"></a>
std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>getAddress</b> () const</td></tr>
<tr class="separator:ab92e46a360736c1c6c5f4a55aad9e264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3aa16d80ccdd818a3ec253cb98e789"><td class="memItemLeft" align="right" valign="top"><a id="acf3aa16d80ccdd818a3ec253cb98e789"></a>
std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>getPort</b> () const</td></tr>
<tr class="separator:acf3aa16d80ccdd818a3ec253cb98e789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95085332f00e12995f472d977eb9728f"><td class="memTemplParams" colspan="2"><a id="a95085332f00e12995f472d977eb9728f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a95085332f00e12995f472d977eb9728f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create</b> (std::size_t maxChannels, std::size_t maxClients, sf::Uint32 incoming, sf::Uint32 outgoing)</td></tr>
<tr class="separator:a95085332f00e12995f472d977eb9728f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2e0a3ba12db4d7feda55eb86e768c9"><td class="memTemplParams" colspan="2"><a id="a9d2e0a3ba12db4d7feda55eb86e768c9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9d2e0a3ba12db4d7feda55eb86e768c9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sendPacket</b> (std::uint8_t id, const T &amp;data, <a class="el" href="namespacexy.html#a05dcce851ad31fdc5bf3179c20b19437">NetFlag</a> flags, sf::Uint8 channel)</td></tr>
<tr class="separator:a9d2e0a3ba12db4d7feda55eb86e768c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Creates a clientside host which can be used to create a peer connected to a <a class="el" href="classxy_1_1_net_host.html" title="Creates a network host. Network hosts, or servers, can have multiple clients connected to them,...">NetHost</a> server. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aa1d253a6d4cba15bb64a68f5c2cd9611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d253a6d4cba15bb64a68f5c2cd9611">&#9670;&nbsp;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xy::NetClient::connect </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sf::Uint16&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sf::Uint32&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>5000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to connect to a server on the given IPv4 address or host name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Address or hostname to connect to. </td></tr>
    <tr><td class="paramname">port</td><td>The port number on which this client will attempt to connect to the server. </td></tr>
    <tr><td class="paramname">timeout</td><td>Number of milliseconds to wait before connection attempt times out. This function is blocking until the server either responds with a connection successful event, or the timeout is reached. The default timeout is 5 seconds, and should be greater than 0, which may falsely return true as the connection attempt will not wait for a response from the server. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false if the attempt timed out. </dd></dl>

</div>
</div>
<a id="a4d640be1f2c864fae2ae4432280180bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d640be1f2c864fae2ae4432280180bb">&#9670;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = EnetClientImpl&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool xy::NetClient::create </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>maxChannels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>maxClients</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sf::Uint32&#160;</td>
          <td class="paramname"><em>incoming</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sf::Uint32&#160;</td>
          <td class="paramname"><em>outgoing</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>brief Creates a client host ready for connection to a server. This must be called at least once before trying to use <a class="el" href="classxy_1_1_net_client.html#aa1d253a6d4cba15bb64a68f5c2cd9611" title="Attempts to connect to a server on the given IPv4 address or host name.">connect()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxChannels</td><td>Maximum number of channels to create on the connection. This should match the number used when creating the <a class="el" href="classxy_1_1_net_host.html" title="Creates a network host. Network hosts, or servers, can have multiple clients connected to them,...">NetHost</a> instance to which this client will connect. </td></tr>
    <tr><td class="paramname">maxClients</td><td>Number of client connections this host will allow to a server. This is usually 1 (default). </td></tr>
    <tr><td class="paramname">incoming</td><td>Maximum incoming bandwidth allowed in bytes per second. </td></tr>
    <tr><td class="paramname">outgoing</td><td>Maximum outgoing bandwidth allow in bytes per second. A value of 0 sets throttling to automatic (default). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful or false if something went wrong Calling this 2 or more times with different parameters will attempt to recreate the host. NOTE: this is a templated function which defaults to the ENet library implementation. Generally this type does not need to be specified, and is useful only when providing a custom netowrking implmentation. </dd></dl>

</div>
</div>
<a id="abe4930f66ef82e3aca6909a885e7c372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4930f66ef82e3aca6909a885e7c372">&#9670;&nbsp;</a></span>getPeer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structxy_1_1_net_peer.html">NetPeer</a>&amp; xy::NetClient::getPeer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the client's peer. Peers are only valid when connected to a server. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structxy_1_1_net_peer.html" title="A peer represents a single, multichannel connection between a client and a host.">NetPeer</a> </dd></dl>

</div>
</div>
<a id="a3dea35c53f26c797cee6a53d29654313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dea35c53f26c797cee6a53d29654313">&#9670;&nbsp;</a></span>pollEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xy::NetClient::pollEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structxy_1_1_net_event.html">NetEvent</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Polls the connection for events. This must be called at least once per frame to make sure all received packets are parsed and pending data is sent. Any data received is placed in the given event object. Make sure this happens on both ends of the connection (<a class="el" href="classxy_1_1_net_host.html" title="Creates a network host. Network hosts, or servers, can have multiple clients connected to them,...">NetHost</a> and <a class="el" href="classxy_1_1_net_client.html" title="Creates a clientside host which can be used to create a peer connected to a NetHost server.">NetClient</a>) </p>
<ul>
<li>this is the most common reason communication fails. <dl class="section return"><dt>Returns</dt><dd>true if there is incoming data in the buffer, else false </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a8a1bb851b6ebf91a77a1e20d05da508f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a1bb851b6ebf91a77a1e20d05da508f">&#9670;&nbsp;</a></span>sendPacket() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void xy::NetClient::sendPacket </td>
          <td>(</td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacexy.html#a05dcce851ad31fdc5bf3179c20b19437">NetFlag</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sf::Uint8&#160;</td>
          <td class="paramname"><em>channel</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a packet to the server if a connection is established, else does nothing. NOTE: Packets are actually queued and not sent over the connection until the next time <a class="el" href="classxy_1_1_net_client.html#a3dea35c53f26c797cee6a53d29654313" title="Polls the connection for events. This must be called at least once per frame to make sure all receive...">pollEvent()</a> is called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>unique ID for this packet </td></tr>
    <tr><td class="paramname">data</td><td>Struct of simple data to send. Structs are serialised and sent out as an array of bytes - thus members such as pointers are effectively useless, as the pointers themselves will be sent, and not the data pointed to. </td></tr>
    <tr><td class="paramname">flags</td><td>Used to denote reliability of packet sending </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacexy.html#a05dcce851ad31fdc5bf3179c20b19437" title="Reliability enum. These are used to flag sent packets with a requested reliability.">NetFlag</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Stream channel on which to send the data. Lower number channels have higher priority, with 0 being highest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a638a42119bcaff2dae0866ab51cb6812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a638a42119bcaff2dae0866ab51cb6812">&#9670;&nbsp;</a></span>sendPacket() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xy::NetClient::sendPacket </td>
          <td>(</td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacexy.html#a05dcce851ad31fdc5bf3179c20b19437">NetFlag</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sf::Uint8&#160;</td>
          <td class="paramname"><em>channel</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends the given array of bytes out over the connection if it is active, else does nothing. Use this for pre-serialised data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Unique ID for this packet </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the data to send </td></tr>
    <tr><td class="paramname">size</td><td>Size of the data, in bytes </td></tr>
    <tr><td class="paramname">flags</td><td>Used to indicated the requested reliability of packet sent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacexy.html#a05dcce851ad31fdc5bf3179c20b19437" title="Reliability enum. These are used to flag sent packets with a requested reliability.">NetFlag</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Stream channel over which to send the data. Lower number channels have higher priority, with 0 being highest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
