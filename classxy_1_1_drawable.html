<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>xyginext: xy::Drawable Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">xyginext
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
   <div id="projectbrief">Second generation of xygine game creation framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacexy.html">xy</a></li><li class="navelem"><a class="el" href="classxy_1_1_drawable.html">Drawable</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classxy_1_1_drawable-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">xy::Drawable Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classxy_1_1_drawable.html" title="Drawable component. The drawable component encapsulates an sf::VertexArray which can be used to draw ...">Drawable</a> component. The drawable component encapsulates an sf::VertexArray which can be used to draw custom shapes, as well as being required for entities which have a sprite or text component. The purpose of the <a class="el" href="classxy_1_1_drawable.html" title="Drawable component. The drawable component encapsulates an sf::VertexArray which can be used to draw ...">Drawable</a> component is to allow mixing <a class="el" href="classxy_1_1_sprite.html" title="Sprite component optimised to work with the ECS. Sprite components require their entity to also have ...">Sprite</a>, <a class="el" href="classxy_1_1_text.html" title="ECS friendly implementation of Text. Text components should appear on entities which also have a tran...">Text</a> and custom drawable types in a single drawing pass with variable depth. A <a class="el" href="classxy_1_1_scene.html" title="Encapsulates a single scene. The scene class contains everything needed to create a scene graph by en...">Scene</a> must have a <a class="el" href="classxy_1_1_render_system.html" title="Used to draw all entities which have a Drawable and Transform component. The RenderSystem is used to ...">RenderSystem</a> added to it to enable any drawable entities.  
 <a href="classxy_1_1_drawable.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_drawable_8hpp_source.html">Drawable.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for xy::Drawable:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxy_1_1_drawable.png" usemap="#xy::Drawable_map" alt=""/>
  <map id="xy::Drawable_map" name="xy::Drawable_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afd96778f5c09d59b97182f94109e0b25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd96778f5c09d59b97182f94109e0b25"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Drawable</b> (const sf::Texture &amp;)</td></tr>
<tr class="separator:afd96778f5c09d59b97182f94109e0b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8cfb39d68e07e571d04cb66ec2a89f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_drawable.html#a7c8cfb39d68e07e571d04cb66ec2a89f">setTexture</a> (const sf::Texture *)</td></tr>
<tr class="memdesc:a7c8cfb39d68e07e571d04cb66ec2a89f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the texture with which to render this drawable. Setting this to nullptr removes the texture. This has no effect when used with <a class="el" href="classxy_1_1_sprite.html" title="Sprite component optimised to work with the ECS. Sprite components require their entity to also have ...">Sprite</a> or <a class="el" href="classxy_1_1_text.html" title="ECS friendly implementation of Text. Text components should appear on entities which also have a tran...">Text</a> components which supply their own textures.  <a href="#a7c8cfb39d68e07e571d04cb66ec2a89f">More...</a><br /></td></tr>
<tr class="separator:a7c8cfb39d68e07e571d04cb66ec2a89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf130f293a20b95c0bfc74037eb4f9bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf130f293a20b95c0bfc74037eb4f9bb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_drawable.html#aaf130f293a20b95c0bfc74037eb4f9bb">setShader</a> (sf::Shader *)</td></tr>
<tr class="memdesc:aaf130f293a20b95c0bfc74037eb4f9bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the shader used when drawing. Passing nullptr removes any active shader. <br /></td></tr>
<tr class="separator:aaf130f293a20b95c0bfc74037eb4f9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741aee6b237edacd26598c52ce167310"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a741aee6b237edacd26598c52ce167310"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_drawable.html#a741aee6b237edacd26598c52ce167310">bindUniform</a> (const std::string &amp;name, const sf::Texture &amp;texture)</td></tr>
<tr class="memdesc:a741aee6b237edacd26598c52ce167310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a uniform binding to be applied to any shader this drawable may have. When sharing a shader between multiple drawables it may be, for instance, desirable to the apply a different texture for each drawble. This function allows mapping a uniform name (assuming it is available in the current shader) to a texture or other value. Bindings are limited to 6 per type. <br /></td></tr>
<tr class="separator:a741aee6b237edacd26598c52ce167310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaedef3c1697d6bdacfa0943d8e493e12"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaedef3c1697d6bdacfa0943d8e493e12"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bindUniform</b> (const std::string &amp;name, float value)</td></tr>
<tr class="separator:aaedef3c1697d6bdacfa0943d8e493e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350e1b371f01bdb824cecd8d6629f99f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a350e1b371f01bdb824cecd8d6629f99f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bindUniform</b> (const std::string &amp;name, sf::Vector2f value)</td></tr>
<tr class="separator:a350e1b371f01bdb824cecd8d6629f99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17763328a31a697af4663f55ad2d885a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17763328a31a697af4663f55ad2d885a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bindUniform</b> (const std::string &amp;name, sf::Vector3f value)</td></tr>
<tr class="separator:a17763328a31a697af4663f55ad2d885a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c560cbd39f6da8c7054bb15745f701"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83c560cbd39f6da8c7054bb15745f701"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bindUniform</b> (const std::string &amp;name, bool value)</td></tr>
<tr class="separator:a83c560cbd39f6da8c7054bb15745f701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa798d708dfe8b37ece463c8f490150"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfa798d708dfe8b37ece463c8f490150"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_drawable.html#abfa798d708dfe8b37ece463c8f490150">bindUniform</a> (const std::string &amp;name, const float *value)</td></tr>
<tr class="memdesc:abfa798d708dfe8b37ece463c8f490150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds a pointer to a float array containing a 4x4 matrix. <br /></td></tr>
<tr class="separator:abfa798d708dfe8b37ece463c8f490150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f919e5a70709c9b21e51bb7383b2ae5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f919e5a70709c9b21e51bb7383b2ae5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_drawable.html#a9f919e5a70709c9b21e51bb7383b2ae5">bindUniformToCurrentTexture</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a9f919e5a70709c9b21e51bb7383b2ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds the given uniform to the value of sf::Shader::CurrentTexture. Up to 6 uniforms may be bound to this value. <br /></td></tr>
<tr class="separator:a9f919e5a70709c9b21e51bb7383b2ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3de615ad63840a15453929727e21982"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3de615ad63840a15453929727e21982"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_drawable.html#ac3de615ad63840a15453929727e21982">setBlendMode</a> (sf::BlendMode)</td></tr>
<tr class="memdesc:ac3de615ad63840a15453929727e21982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the blend mode used when drawing. <br /></td></tr>
<tr class="separator:ac3de615ad63840a15453929727e21982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1cb6b841ccfc8970d89f636c363c37f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1cb6b841ccfc8970d89f636c363c37f"></a>
sf::Texture *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_drawable.html#aa1cb6b841ccfc8970d89f636c363c37f">getTexture</a> ()</td></tr>
<tr class="memdesc:aa1cb6b841ccfc8970d89f636c363c37f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the active texture. <br /></td></tr>
<tr class="separator:aa1cb6b841ccfc8970d89f636c363c37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e335864b115becfd6f174dc7d46735"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48e335864b115becfd6f174dc7d46735"></a>
sf::Shader *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_drawable.html#a48e335864b115becfd6f174dc7d46735">getShader</a> ()</td></tr>
<tr class="memdesc:a48e335864b115becfd6f174dc7d46735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the active shader, if any. <br /></td></tr>
<tr class="separator:a48e335864b115becfd6f174dc7d46735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb58f1c76cbcc1ba11f377bc64ebc3ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb58f1c76cbcc1ba11f377bc64ebc3ef"></a>
sf::BlendMode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_drawable.html#adb58f1c76cbcc1ba11f377bc64ebc3ef">getBlendMode</a> () const </td></tr>
<tr class="memdesc:adb58f1c76cbcc1ba11f377bc64ebc3ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current blend mode. <br /></td></tr>
<tr class="separator:adb58f1c76cbcc1ba11f377bc64ebc3ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0651ab05ecaa58bef158364523ce201d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0651ab05ecaa58bef158364523ce201d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_drawable.html#a0651ab05ecaa58bef158364523ce201d">setDepth</a> (sf::Int32 depth)</td></tr>
<tr class="memdesc:a0651ab05ecaa58bef158364523ce201d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the z-depth of a drawable. The lower the value the further back the entity is drawn, inversely the greater the value the further forward it is drawn. Default value is 0. <br /></td></tr>
<tr class="separator:a0651ab05ecaa58bef158364523ce201d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283f8907ee84c6572397774d9db50406"><td class="memItemLeft" align="right" valign="top">sf::Int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_drawable.html#a283f8907ee84c6572397774d9db50406">getDepth</a> () const </td></tr>
<tr class="memdesc:a283f8907ee84c6572397774d9db50406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Z depth value.  <a href="#a283f8907ee84c6572397774d9db50406">More...</a><br /></td></tr>
<tr class="separator:a283f8907ee84c6572397774d9db50406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9a45f3e4717a659d520973cf9a4014"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f9a45f3e4717a659d520973cf9a4014"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_drawable.html#a6f9a45f3e4717a659d520973cf9a4014">setCroppingArea</a> (sf::FloatRect)</td></tr>
<tr class="memdesc:a6f9a45f3e4717a659d520973cf9a4014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an area to which to crop the drawable. The given rectangle should be in local coordinates, relative to the drawable. <br /></td></tr>
<tr class="separator:a6f9a45f3e4717a659d520973cf9a4014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5ae30af1542ed048f5153aa9e7a68a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b5ae30af1542ed048f5153aa9e7a68a"></a>
sf::FloatRect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_drawable.html#a2b5ae30af1542ed048f5153aa9e7a68a">getCroppingArea</a> () const </td></tr>
<tr class="memdesc:a2b5ae30af1542ed048f5153aa9e7a68a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current cropping area. <br /></td></tr>
<tr class="separator:a2b5ae30af1542ed048f5153aa9e7a68a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6373f8a2087c47cdc9ac28a01cb14f7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6373f8a2087c47cdc9ac28a01cb14f7f"></a>
std::vector&lt; sf::Vertex &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_drawable.html#a6373f8a2087c47cdc9ac28a01cb14f7f">getVertices</a> ()</td></tr>
<tr class="memdesc:a6373f8a2087c47cdc9ac28a01cb14f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the vertex array used when drawing. <br /></td></tr>
<tr class="separator:a6373f8a2087c47cdc9ac28a01cb14f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64f7586caa5ca1987f7b84f8daba17c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab64f7586caa5ca1987f7b84f8daba17c"></a>
const std::vector&lt; sf::Vertex &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getVertices</b> () const </td></tr>
<tr class="separator:ab64f7586caa5ca1987f7b84f8daba17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b591ba8129979d9cec9af952cdc58b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89b591ba8129979d9cec9af952cdc58b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_drawable.html#a89b591ba8129979d9cec9af952cdc58b">setPrimitiveType</a> (sf::PrimitiveType type)</td></tr>
<tr class="memdesc:a89b591ba8129979d9cec9af952cdc58b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the PrimitiveType used by the drawable. Uses sf::Quads by default. <br /></td></tr>
<tr class="separator:a89b591ba8129979d9cec9af952cdc58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033a54b7450ca2411aac9d56d99dca25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a033a54b7450ca2411aac9d56d99dca25"></a>
sf::PrimitiveType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_drawable.html#a033a54b7450ca2411aac9d56d99dca25">getPrimitiveType</a> () const </td></tr>
<tr class="memdesc:a033a54b7450ca2411aac9d56d99dca25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current PrimitiveType used to draw the vertices. <br /></td></tr>
<tr class="separator:a033a54b7450ca2411aac9d56d99dca25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37cfa1db27537161c1313523dfd4dcfa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37cfa1db27537161c1313523dfd4dcfa"></a>
sf::FloatRect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_drawable.html#a37cfa1db27537161c1313523dfd4dcfa">getLocalBounds</a> () const </td></tr>
<tr class="memdesc:a37cfa1db27537161c1313523dfd4dcfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the local bounds of the <a class="el" href="classxy_1_1_drawable.html" title="Drawable component. The drawable component encapsulates an sf::VertexArray which can be used to draw ...">Drawable</a>'s vertex array. This should be updated by any systems which implement custom drawables else culling will failed and drawable will not appear on screen. <br /></td></tr>
<tr class="separator:a37cfa1db27537161c1313523dfd4dcfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1816bf3922c232b59576aa7034ce5a4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1816bf3922c232b59576aa7034ce5a4b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_drawable.html#a1816bf3922c232b59576aa7034ce5a4b">updateLocalBounds</a> ()</td></tr>
<tr class="memdesc:a1816bf3922c232b59576aa7034ce5a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the local bounds. This should be called once by a system when it updates the vertex array. As this is used by the render system for culling, <a class="el" href="classxy_1_1_drawable.html" title="Drawable component. The drawable component encapsulates an sf::VertexArray which can be used to draw ...">Drawable</a> components will not be drawn if the bounds have not been updated. <br /></td></tr>
<tr class="separator:a1816bf3922c232b59576aa7034ce5a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6eaf0c0f079eafff100edd3848ec591"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6eaf0c0f079eafff100edd3848ec591"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateLocalBounds</b> (sf::FloatRect)</td></tr>
<tr class="separator:ad6eaf0c0f079eafff100edd3848ec591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66239fb5c5cdac1da4c89b1bee6c0315"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_drawable.html#a66239fb5c5cdac1da4c89b1bee6c0315">setCulled</a> (bool cull)</td></tr>
<tr class="memdesc:a66239fb5c5cdac1da4c89b1bee6c0315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables viewport culling. By default Drawables are culled from rendering when not in the viewable area of the active camera. Setting this to true will cause the drawable to always be rendered, even if it falls outside the active camera's view.  <a href="#a66239fb5c5cdac1da4c89b1bee6c0315">More...</a><br /></td></tr>
<tr class="separator:a66239fb5c5cdac1da4c89b1bee6c0315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f69d7772bc51e35ec5eeb93b4c8f10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86f69d7772bc51e35ec5eeb93b4c8f10"></a>
sf::RenderStates&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_drawable.html#a86f69d7772bc51e35ec5eeb93b4c8f10">getStates</a> () const </td></tr>
<tr class="memdesc:a86f69d7772bc51e35ec5eeb93b4c8f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the RenderStates containing the current blend mode, PrimitiveType and Shader of the drawable. Generally not required, unless implementing a custom renderer. <br /></td></tr>
<tr class="separator:a86f69d7772bc51e35ec5eeb93b4c8f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b21eddd30fe16f76cd01e92a5f42c77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b21eddd30fe16f76cd01e92a5f42c77"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_drawable.html#a9b21eddd30fe16f76cd01e92a5f42c77">applyShader</a> () const </td></tr>
<tr class="memdesc:a9b21eddd30fe16f76cd01e92a5f42c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies all the unform bindings to the current shader. Generally not used unless implementing a custom render system, in which case this should be called immediately before the component is drawn. <br /></td></tr>
<tr class="separator:a9b21eddd30fe16f76cd01e92a5f42c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a06b786d8e0847dfe9cc15e1dea308fcd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06b786d8e0847dfe9cc15e1dea308fcd"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>RenderSystem</b></td></tr>
<tr class="separator:a06b786d8e0847dfe9cc15e1dea308fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classxy_1_1_drawable.html" title="Drawable component. The drawable component encapsulates an sf::VertexArray which can be used to draw ...">Drawable</a> component. The drawable component encapsulates an sf::VertexArray which can be used to draw custom shapes, as well as being required for entities which have a sprite or text component. The purpose of the <a class="el" href="classxy_1_1_drawable.html" title="Drawable component. The drawable component encapsulates an sf::VertexArray which can be used to draw ...">Drawable</a> component is to allow mixing <a class="el" href="classxy_1_1_sprite.html" title="Sprite component optimised to work with the ECS. Sprite components require their entity to also have ...">Sprite</a>, <a class="el" href="classxy_1_1_text.html" title="ECS friendly implementation of Text. Text components should appear on entities which also have a tran...">Text</a> and custom drawable types in a single drawing pass with variable depth. A <a class="el" href="classxy_1_1_scene.html" title="Encapsulates a single scene. The scene class contains everything needed to create a scene graph by en...">Scene</a> must have a <a class="el" href="classxy_1_1_render_system.html" title="Used to draw all entities which have a Drawable and Transform component. The RenderSystem is used to ...">RenderSystem</a> added to it to enable any drawable entities. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a283f8907ee84c6572397774d9db50406"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sf::Int32 xy::Drawable::getDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Z depth value. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classxy_1_1_drawable.html#a0651ab05ecaa58bef158364523ce201d" title="Sets the z-depth of a drawable. The lower the value the further back the entity is drawn...">setDepth()</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="a66239fb5c5cdac1da4c89b1bee6c0315"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xy::Drawable::setCulled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cull</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables or disables viewport culling. By default Drawables are culled from rendering when not in the viewable area of the active camera. Setting this to true will cause the drawable to always be rendered, even if it falls outside the active camera's view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cull</td><td>Set to true to have the drawble culled from rendering when not intersecting the current viewable area. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7c8cfb39d68e07e571d04cb66ec2a89f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xy::Drawable::setTexture </td>
          <td>(</td>
          <td class="paramtype">const sf::Texture *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the texture with which to render this drawable. Setting this to nullptr removes the texture. This has no effect when used with <a class="el" href="classxy_1_1_sprite.html" title="Sprite component optimised to work with the ECS. Sprite components require their entity to also have ...">Sprite</a> or <a class="el" href="classxy_1_1_text.html" title="ECS friendly implementation of Text. Text components should appear on entities which also have a tran...">Text</a> components which supply their own textures. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classxy_1_1_sprite.html#abd25d323c036ba3974917850a443d757" title="Sets the texture with which to draw this sprite. By default sprites are resized to the size of this t...">Sprite::setTexture()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
