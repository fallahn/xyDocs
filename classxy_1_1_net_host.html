<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>xyginext: xy::NetHost Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">xyginext
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
   <div id="projectbrief">Second generation of xygine game creation framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacexy.html">xy</a></li><li class="navelem"><a class="el" href="classxy_1_1_net_host.html">NetHost</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classxy_1_1_net_host-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">xy::NetHost Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Creates a network host. Network hosts, or servers, can have multiple clients connected to them, via a reliable UDP stream.  
 <a href="classxy_1_1_net_host.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_net_host_8hpp_source.html">NetHost.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2468e993348f36b7426e0b0cddfa4889"><td class="memItemLeft" align="right" valign="top"><a id="a2468e993348f36b7426e0b0cddfa4889"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NetHost</b> (const <a class="el" href="classxy_1_1_net_host.html">NetHost</a> &amp;)=delete</td></tr>
<tr class="separator:a2468e993348f36b7426e0b0cddfa4889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f3a3dfe092213295b411fb6885147c"><td class="memItemLeft" align="right" valign="top"><a id="ae6f3a3dfe092213295b411fb6885147c"></a>
<a class="el" href="classxy_1_1_net_host.html">NetHost</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classxy_1_1_net_host.html">NetHost</a> &amp;)=delete</td></tr>
<tr class="separator:ae6f3a3dfe092213295b411fb6885147c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7659a515685270700483282064d48f46"><td class="memItemLeft" align="right" valign="top"><a id="a7659a515685270700483282064d48f46"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NetHost</b> (<a class="el" href="classxy_1_1_net_host.html">NetHost</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a7659a515685270700483282064d48f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8237a94f0b47c39208fda30c875280"><td class="memItemLeft" align="right" valign="top"><a id="adb8237a94f0b47c39208fda30c875280"></a>
<a class="el" href="classxy_1_1_net_host.html">NetHost</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classxy_1_1_net_host.html">NetHost</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:adb8237a94f0b47c39208fda30c875280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b202a811bcaed92b05380a02adb509"><td class="memTemplParams" colspan="2">template&lt;typename T  = EnetHostImpl&gt; </td></tr>
<tr class="memitem:a18b202a811bcaed92b05380a02adb509"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxy_1_1_net_host.html#a18b202a811bcaed92b05380a02adb509">start</a> (const std::string &amp;address, sf::Uint16 port, std::size_t maxClient, std::size_t maxChannels, sf::Uint32 incoming=0, sf::Uint32 outgoing=0)</td></tr>
<tr class="memdesc:a18b202a811bcaed92b05380a02adb509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a host listening on the given address and port.  <a href="classxy_1_1_net_host.html#a18b202a811bcaed92b05380a02adb509">More...</a><br /></td></tr>
<tr class="separator:a18b202a811bcaed92b05380a02adb509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89dd1384f4646a387805544625911a8c"><td class="memItemLeft" align="right" valign="top"><a id="a89dd1384f4646a387805544625911a8c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_net_host.html#a89dd1384f4646a387805544625911a8c">stop</a> ()</td></tr>
<tr class="memdesc:a89dd1384f4646a387805544625911a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the host, if it is running. <br /></td></tr>
<tr class="separator:a89dd1384f4646a387805544625911a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aec87f387cde7b2640fd58fc738fe21"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_net_host.html#a9aec87f387cde7b2640fd58fc738fe21">pollEvent</a> (<a class="el" href="structxy_1_1_net_event.html">NetEvent</a> &amp;)</td></tr>
<tr class="memdesc:a9aec87f387cde7b2640fd58fc738fe21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polls the connection for events. This must be called at least once per frame to make sure all received packets are parsed and pending data is sent. Any data received is placed in the given event object. Make sure this happens on both ends of the connection (<a class="el" href="classxy_1_1_net_host.html" title="Creates a network host. Network hosts, or servers, can have multiple clients connected to them,...">NetHost</a> and <a class="el" href="classxy_1_1_net_client.html" title="Creates a clientside host which can be used to create a peer connected to a NetHost server.">NetClient</a>)  <a href="classxy_1_1_net_host.html#a9aec87f387cde7b2640fd58fc738fe21">More...</a><br /></td></tr>
<tr class="separator:a9aec87f387cde7b2640fd58fc738fe21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343ce2d8e58e569cf5f5ee53368939e4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a343ce2d8e58e569cf5f5ee53368939e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxy_1_1_net_host.html#a343ce2d8e58e569cf5f5ee53368939e4">broadcastPacket</a> (std::uint8_t id, const T &amp;data, <a class="el" href="namespacexy.html#a05dcce851ad31fdc5bf3179c20b19437">NetFlag</a> flags, sf::Uint8 channel=0)</td></tr>
<tr class="memdesc:a343ce2d8e58e569cf5f5ee53368939e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts a packet to all connected clients. Note that all packets are queued until the next time <a class="el" href="classxy_1_1_net_host.html#a9aec87f387cde7b2640fd58fc738fe21" title="Polls the connection for events. This must be called at least once per frame to make sure all receive...">pollEvent()</a> is called.  <a href="classxy_1_1_net_host.html#a343ce2d8e58e569cf5f5ee53368939e4">More...</a><br /></td></tr>
<tr class="separator:a343ce2d8e58e569cf5f5ee53368939e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7debe61eb3b7d1539eb0102cf29e81ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_net_host.html#a7debe61eb3b7d1539eb0102cf29e81ab">broadcastPacket</a> (std::uint8_t id, const void *data, std::size_t size, <a class="el" href="namespacexy.html#a05dcce851ad31fdc5bf3179c20b19437">NetFlag</a> flags, sf::Uint8 channel=0)</td></tr>
<tr class="memdesc:a7debe61eb3b7d1539eb0102cf29e81ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts the given stream of bytes to all connected clients Use this for pre-serialised data.  <a href="classxy_1_1_net_host.html#a7debe61eb3b7d1539eb0102cf29e81ab">More...</a><br /></td></tr>
<tr class="separator:a7debe61eb3b7d1539eb0102cf29e81ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5cb2e55d5b883c9888d167d63711de"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5b5cb2e55d5b883c9888d167d63711de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxy_1_1_net_host.html#a5b5cb2e55d5b883c9888d167d63711de">sendPacket</a> (const <a class="el" href="structxy_1_1_net_peer.html">NetPeer</a> &amp;peer, std::uint8_t id, const T &amp;data, <a class="el" href="namespacexy.html#a05dcce851ad31fdc5bf3179c20b19437">NetFlag</a> flags, sf::Uint8 channel=0)</td></tr>
<tr class="memdesc:a5b5cb2e55d5b883c9888d167d63711de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a packet to the given peer if a connection is established, else does nothing. NOTE: Packets are actually queued and not sent over the connection until the next time <a class="el" href="classxy_1_1_net_host.html#a9aec87f387cde7b2640fd58fc738fe21" title="Polls the connection for events. This must be called at least once per frame to make sure all receive...">pollEvent()</a> is called.  <a href="classxy_1_1_net_host.html#a5b5cb2e55d5b883c9888d167d63711de">More...</a><br /></td></tr>
<tr class="separator:a5b5cb2e55d5b883c9888d167d63711de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab551b1ef54d247ff4eb2f82986a3aaea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_net_host.html#ab551b1ef54d247ff4eb2f82986a3aaea">sendPacket</a> (const <a class="el" href="structxy_1_1_net_peer.html">NetPeer</a> &amp;peer, std::uint8_t id, const void *data, std::size_t size, <a class="el" href="namespacexy.html#a05dcce851ad31fdc5bf3179c20b19437">NetFlag</a> flags, sf::Uint8 channel=0)</td></tr>
<tr class="memdesc:ab551b1ef54d247ff4eb2f82986a3aaea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the given array of bytes out over the given peer if it is active, else does nothing. Use this for pre-serialised data.  <a href="classxy_1_1_net_host.html#ab551b1ef54d247ff4eb2f82986a3aaea">More...</a><br /></td></tr>
<tr class="separator:ab551b1ef54d247ff4eb2f82986a3aaea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365a5654b278006344b22b0ef233a002"><td class="memItemLeft" align="right" valign="top"><a id="a365a5654b278006344b22b0ef233a002"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_net_host.html#a365a5654b278006344b22b0ef233a002">getConnectedPeerCount</a> () const</td></tr>
<tr class="memdesc:a365a5654b278006344b22b0ef233a002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of currently connected peers. <br /></td></tr>
<tr class="separator:a365a5654b278006344b22b0ef233a002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9a7385f43183cd4bdaaeceadc04635"><td class="memItemLeft" align="right" valign="top"><a id="a7f9a7385f43183cd4bdaaeceadc04635"></a>
std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>getAddress</b> () const</td></tr>
<tr class="separator:a7f9a7385f43183cd4bdaaeceadc04635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0010362aca51ac954548bbc988569d24"><td class="memItemLeft" align="right" valign="top"><a id="a0010362aca51ac954548bbc988569d24"></a>
std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>getPort</b> () const</td></tr>
<tr class="separator:a0010362aca51ac954548bbc988569d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae86364c85e74a18826340ddd889593"><td class="memTemplParams" colspan="2"><a id="a8ae86364c85e74a18826340ddd889593"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8ae86364c85e74a18826340ddd889593"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>start</b> (const std::string &amp;address, sf::Uint16 port, std::size_t maxClients, std::size_t maxChannels, sf::Uint32 incoming, sf::Uint32 outgoing)</td></tr>
<tr class="separator:a8ae86364c85e74a18826340ddd889593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340aa486bfe035be767cddc5b642abda"><td class="memTemplParams" colspan="2"><a id="a340aa486bfe035be767cddc5b642abda"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a340aa486bfe035be767cddc5b642abda"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>broadcastPacket</b> (std::uint8_t id, const T &amp;data, <a class="el" href="namespacexy.html#a05dcce851ad31fdc5bf3179c20b19437">NetFlag</a> flags, sf::Uint8 channel)</td></tr>
<tr class="separator:a340aa486bfe035be767cddc5b642abda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21faedb4007cdf165386e28d59eee97"><td class="memTemplParams" colspan="2"><a id="ac21faedb4007cdf165386e28d59eee97"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac21faedb4007cdf165386e28d59eee97"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sendPacket</b> (const <a class="el" href="structxy_1_1_net_peer.html">NetPeer</a> &amp;peer, std::uint8_t id, const T &amp;data, <a class="el" href="namespacexy.html#a05dcce851ad31fdc5bf3179c20b19437">NetFlag</a> flags, sf::Uint8 channel)</td></tr>
<tr class="separator:ac21faedb4007cdf165386e28d59eee97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Creates a network host. Network hosts, or servers, can have multiple clients connected to them, via a reliable UDP stream. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a343ce2d8e58e569cf5f5ee53368939e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a343ce2d8e58e569cf5f5ee53368939e4">&#9670;&nbsp;</a></span>broadcastPacket() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void xy::NetHost::broadcastPacket </td>
          <td>(</td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacexy.html#a05dcce851ad31fdc5bf3179c20b19437">NetFlag</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sf::Uint8&#160;</td>
          <td class="paramname"><em>channel</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcasts a packet to all connected clients. Note that all packets are queued until the next time <a class="el" href="classxy_1_1_net_host.html#a9aec87f387cde7b2640fd58fc738fe21" title="Polls the connection for events. This must be called at least once per frame to make sure all receive...">pollEvent()</a> is called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>unique ID for this packet </td></tr>
    <tr><td class="paramname">data</td><td>Struct of simple data to send. Structs are serialised and sent out as an array of bytes - thus members such as pointers are effectively useless, as the pointers themselves will be sent, and not the data pointed to. </td></tr>
    <tr><td class="paramname">flags</td><td>Used to denote reliability of packet sending </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacexy.html#a05dcce851ad31fdc5bf3179c20b19437" title="Reliability enum. These are used to flag sent packets with a requested reliability.">NetFlag</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Stream channel on which to send the data. Lower number channels have higher priority, with 0 being highest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7debe61eb3b7d1539eb0102cf29e81ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7debe61eb3b7d1539eb0102cf29e81ab">&#9670;&nbsp;</a></span>broadcastPacket() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xy::NetHost::broadcastPacket </td>
          <td>(</td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacexy.html#a05dcce851ad31fdc5bf3179c20b19437">NetFlag</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sf::Uint8&#160;</td>
          <td class="paramname"><em>channel</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcasts the given stream of bytes to all connected clients Use this for pre-serialised data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Unique ID for this packet </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the data to send </td></tr>
    <tr><td class="paramname">size</td><td>Size of the data, in bytes </td></tr>
    <tr><td class="paramname">flags</td><td>Used to indicated the requested reliability of packet sent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacexy.html#a05dcce851ad31fdc5bf3179c20b19437" title="Reliability enum. These are used to flag sent packets with a requested reliability.">NetFlag</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Stream channel over which to send the data. Lower number channels have higher priority, with 0 being highest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9aec87f387cde7b2640fd58fc738fe21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aec87f387cde7b2640fd58fc738fe21">&#9670;&nbsp;</a></span>pollEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xy::NetHost::pollEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structxy_1_1_net_event.html">NetEvent</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Polls the connection for events. This must be called at least once per frame to make sure all received packets are parsed and pending data is sent. Any data received is placed in the given event object. Make sure this happens on both ends of the connection (<a class="el" href="classxy_1_1_net_host.html" title="Creates a network host. Network hosts, or servers, can have multiple clients connected to them,...">NetHost</a> and <a class="el" href="classxy_1_1_net_client.html" title="Creates a clientside host which can be used to create a peer connected to a NetHost server.">NetClient</a>) </p>
<ul>
<li>this is the most common reason communication fails. <dl class="section return"><dt>Returns</dt><dd>true if there is incoming data in the buffer, else false </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a5b5cb2e55d5b883c9888d167d63711de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b5cb2e55d5b883c9888d167d63711de">&#9670;&nbsp;</a></span>sendPacket() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void xy::NetHost::sendPacket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structxy_1_1_net_peer.html">NetPeer</a> &amp;&#160;</td>
          <td class="paramname"><em>peer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacexy.html#a05dcce851ad31fdc5bf3179c20b19437">NetFlag</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sf::Uint8&#160;</td>
          <td class="paramname"><em>channel</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a packet to the given peer if a connection is established, else does nothing. NOTE: Packets are actually queued and not sent over the connection until the next time <a class="el" href="classxy_1_1_net_host.html#a9aec87f387cde7b2640fd58fc738fe21" title="Polls the connection for events. This must be called at least once per frame to make sure all receive...">pollEvent()</a> is called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peer</td><td>The peer over which to send the packet. </td></tr>
    <tr><td class="paramname">id</td><td>unique ID for this packet </td></tr>
    <tr><td class="paramname">data</td><td>Struct of simple data to send. Structs are serialised and sent out as an array of bytes - thus members such as pointers are effectively useless, as the pointers themselves will be sent, and not the data pointed to. </td></tr>
    <tr><td class="paramname">flags</td><td>Used to denote reliability of packet sending </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacexy.html#a05dcce851ad31fdc5bf3179c20b19437" title="Reliability enum. These are used to flag sent packets with a requested reliability.">NetFlag</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Stream channel on which to send the data. Lower number channels have higher priority, with 0 being highest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab551b1ef54d247ff4eb2f82986a3aaea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab551b1ef54d247ff4eb2f82986a3aaea">&#9670;&nbsp;</a></span>sendPacket() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xy::NetHost::sendPacket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structxy_1_1_net_peer.html">NetPeer</a> &amp;&#160;</td>
          <td class="paramname"><em>peer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacexy.html#a05dcce851ad31fdc5bf3179c20b19437">NetFlag</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sf::Uint8&#160;</td>
          <td class="paramname"><em>channel</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends the given array of bytes out over the given peer if it is active, else does nothing. Use this for pre-serialised data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peer</td><td>The peer over which to send the packet. </td></tr>
    <tr><td class="paramname">id</td><td>Unique ID for this packet </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the data to send </td></tr>
    <tr><td class="paramname">size</td><td>Size of the data, in bytes </td></tr>
    <tr><td class="paramname">flags</td><td>Used to indicated the requested reliability of packet sent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacexy.html#a05dcce851ad31fdc5bf3179c20b19437" title="Reliability enum. These are used to flag sent packets with a requested reliability.">NetFlag</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Stream channel over which to send the data. Lower number channels have higher priority, with 0 being highest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18b202a811bcaed92b05380a02adb509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b202a811bcaed92b05380a02adb509">&#9670;&nbsp;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = EnetHostImpl&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool xy::NetHost::start </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sf::Uint16&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>maxClient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>maxChannels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sf::Uint32&#160;</td>
          <td class="paramname"><em>incoming</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sf::Uint32&#160;</td>
          <td class="paramname"><em>outgoing</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a host listening on the given address and port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>String representing an IPv4 address in the form "x.x.x.x". This may be left empty to listen on any available address. </td></tr>
    <tr><td class="paramname">port</td><td>An unsigned short representing the port on which to listen </td></tr>
    <tr><td class="paramname">maxClient</td><td>Maximum number of connections to allow to the host </td></tr>
    <tr><td class="paramname">maxChannels</td><td>Maximum number of channels allowed (indexed from 0) </td></tr>
    <tr><td class="paramname">incoming</td><td>Limit the incoming bandwidth in bytes per second. 0 is no limit (default) </td></tr>
    <tr><td class="paramname">outgoing</td><td>Limit the outgoing bandwidth in bytes per second. 0 is no limit (default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if created successfully, else false. NOTE Although this function is a template it is generally not required to pass a type here, unless specifying a custom network implementation. This needs to be called at least once before attempting to use any of the other functions in this class </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
