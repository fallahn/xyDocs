<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>xygine: xy::tmx::Map Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">xygine
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">SFML Based 2D Game Creation Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacexy.html">xy</a></li><li class="navelem"><b>tmx</b></li><li class="navelem"><a class="el" href="classxy_1_1tmx_1_1_map.html">Map</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classxy_1_1tmx_1_1_map-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">xy::tmx::Map Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Parser for TMX format tile maps. This class can be used to parse the XML format tile maps created with the Tiled map editor, providing an interface to create xygine compatible Drawable and <a class="el" href="namespacexy_1_1_physics.html" title="Classes relating to xygine&#39;s physics binding. ">Physics</a> components, which can be used in a scene graph. Typical usage would be to create an instance of this class before calling <a class="el" href="classxy_1_1tmx_1_1_map.html#afa755e5d3505eeb1629d52517f159f7c" title="Attempts to parse the tilemap at the given location. ">load()</a> providing a path to the *.tmx file to load. Then layers or objects can be requested from the <a class="el" href="classxy_1_1tmx_1_1_map.html" title="Parser for TMX format tile maps. This class can be used to parse the XML format tile maps created wit...">Map</a> class to be returned as xygine components. Once the components are added to a <a class="el" href="classxy_1_1_scene.html" title="Scene class. ">Scene</a> they can be interacted with in the same way as any other xygine Entity/Component, providing a flexible interface with tile maps.  
 <a href="classxy_1_1tmx_1_1_map.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_map_8hpp_source.html">Map.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a97d832b596bca4be93d1ef41f8cbd5f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97d832b596bca4be93d1ef41f8cbd5f5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Map</b> (const <a class="el" href="classxy_1_1tmx_1_1_map.html">Map</a> &amp;)=delete</td></tr>
<tr class="separator:a97d832b596bca4be93d1ef41f8cbd5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5232e52651f3931627a03e863d23c08f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5232e52651f3931627a03e863d23c08f"></a>
<a class="el" href="classxy_1_1tmx_1_1_map.html">Map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classxy_1_1tmx_1_1_map.html">Map</a> &amp;)=delete</td></tr>
<tr class="separator:a5232e52651f3931627a03e863d23c08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa755e5d3505eeb1629d52517f159f7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1tmx_1_1_map.html#afa755e5d3505eeb1629d52517f159f7c">load</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:afa755e5d3505eeb1629d52517f159f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to parse the tilemap at the given location.  <a href="#afa755e5d3505eeb1629d52517f159f7c">More...</a><br /></td></tr>
<tr class="separator:afa755e5d3505eeb1629d52517f159f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4b60f4466ec5695c7104c71393c289"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c4b60f4466ec5695c7104c71393c289"></a>
const <a class="el" href="structxy_1_1tmx_1_1_version.html">Version</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1tmx_1_1_map.html#a2c4b60f4466ec5695c7104c71393c289">getVersion</a> () const </td></tr>
<tr class="memdesc:a2c4b60f4466ec5695c7104c71393c289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the version of the tile map last parsed. If no tile map has yet been parsed the version will read 0, 0. <br /></td></tr>
<tr class="separator:a2c4b60f4466ec5695c7104c71393c289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc6e7fc6b321a06e3fb3c8e5b64fe37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8cc6e7fc6b321a06e3fb3c8e5b64fe37"></a>
Orientation&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1tmx_1_1_map.html#a8cc6e7fc6b321a06e3fb3c8e5b64fe37">getOrientation</a> () const </td></tr>
<tr class="memdesc:a8cc6e7fc6b321a06e3fb3c8e5b64fe37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the orientation of the map if one is loaded, else returns None. <br /></td></tr>
<tr class="separator:a8cc6e7fc6b321a06e3fb3c8e5b64fe37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc068f40d373f14f5f8a9a68aaeb10ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc068f40d373f14f5f8a9a68aaeb10ae"></a>
RenderOrder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1tmx_1_1_map.html#adc068f40d373f14f5f8a9a68aaeb10ae">getRenderOrder</a> () const </td></tr>
<tr class="memdesc:adc068f40d373f14f5f8a9a68aaeb10ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the RenderOrder of the map if one is loaded, else returns None. <br /></td></tr>
<tr class="separator:adc068f40d373f14f5f8a9a68aaeb10ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861d0ff9098d484d1828f1702155fb01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a861d0ff9098d484d1828f1702155fb01"></a>
const sf::Vector2u &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1tmx_1_1_map.html#a861d0ff9098d484d1828f1702155fb01">getTileCount</a> () const </td></tr>
<tr class="memdesc:a861d0ff9098d484d1828f1702155fb01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tile count of the map in the X and Y directions. <br /></td></tr>
<tr class="separator:a861d0ff9098d484d1828f1702155fb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593d1e1e5f08526766a4e5f64eb0fca5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a593d1e1e5f08526766a4e5f64eb0fca5"></a>
const sf::Vector2u &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1tmx_1_1_map.html#a593d1e1e5f08526766a4e5f64eb0fca5">getTileSize</a> () const </td></tr>
<tr class="memdesc:a593d1e1e5f08526766a4e5f64eb0fca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the tile grid in this map. Actual tile sizes may vary and will be exteded / shrunk about the bottom left corner of the tile. <br /></td></tr>
<tr class="separator:a593d1e1e5f08526766a4e5f64eb0fca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fbae565753032853576e60d720641f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41fbae565753032853576e60d720641f"></a>
sf::FloatRect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1tmx_1_1_map.html#a41fbae565753032853576e60d720641f">getBounds</a> () const </td></tr>
<tr class="memdesc:a41fbae565753032853576e60d720641f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bounds of the map in SFML units. <br /></td></tr>
<tr class="separator:a41fbae565753032853576e60d720641f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e810eb3aa5fd20b8c90c89351d7aab6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e810eb3aa5fd20b8c90c89351d7aab6"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1tmx_1_1_map.html#a7e810eb3aa5fd20b8c90c89351d7aab6">getHexSideLength</a> () const </td></tr>
<tr class="memdesc:a7e810eb3aa5fd20b8c90c89351d7aab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of an edge of a tile if a Hexagonal map is loaded. The length returned is in pixels of the straight edge running along the axis returned by <a class="el" href="classxy_1_1tmx_1_1_map.html#a8dcfa7115c26d5229de1499c3487062c" title="Stagger axis of the map. If either a Staggered or Hexagonal tile map is loaded this returns which axi...">getStaggerAxis()</a>. If no map is loaded or the loaded map is not of Hexagonal orientation this function returns 0.f. <br /></td></tr>
<tr class="separator:a7e810eb3aa5fd20b8c90c89351d7aab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dcfa7115c26d5229de1499c3487062c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8dcfa7115c26d5229de1499c3487062c"></a>
StaggerAxis&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1tmx_1_1_map.html#a8dcfa7115c26d5229de1499c3487062c">getStaggerAxis</a> () const </td></tr>
<tr class="memdesc:a8dcfa7115c26d5229de1499c3487062c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stagger axis of the map. If either a Staggered or Hexagonal tile map is loaded this returns which axis the map is staggered along, else returns None. <br /></td></tr>
<tr class="separator:a8dcfa7115c26d5229de1499c3487062c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8aa7cd61e727d0592e27f5390e7abcd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8aa7cd61e727d0592e27f5390e7abcd"></a>
StaggerIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1tmx_1_1_map.html#af8aa7cd61e727d0592e27f5390e7abcd">getStaggerIndex</a> () const </td></tr>
<tr class="memdesc:af8aa7cd61e727d0592e27f5390e7abcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stagger Index of the loaded map. If a Staggered or Hexagonal map is loaded this returns whether the even or odd rows of tiles are staggered, otherwise it returns None. <br /></td></tr>
<tr class="separator:af8aa7cd61e727d0592e27f5390e7abcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabec00d828342c39f24336495541111"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adabec00d828342c39f24336495541111"></a>
const sf::Color &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1tmx_1_1_map.html#adabec00d828342c39f24336495541111">getBackgroundColour</a> () const </td></tr>
<tr class="memdesc:adabec00d828342c39f24336495541111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the background colour of the map. <br /></td></tr>
<tr class="separator:adabec00d828342c39f24336495541111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39d3e82f3f7d5393f1c3aaa9b471a42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad39d3e82f3f7d5393f1c3aaa9b471a42"></a>
const std::vector&lt; <a class="el" href="classxy_1_1tmx_1_1_tileset.html">Tileset</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1tmx_1_1_map.html#ad39d3e82f3f7d5393f1c3aaa9b471a42">getTilesets</a> () const </td></tr>
<tr class="memdesc:ad39d3e82f3f7d5393f1c3aaa9b471a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the vector of tile sets used by the map. <br /></td></tr>
<tr class="separator:ad39d3e82f3f7d5393f1c3aaa9b471a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290cbb5645c6ac8ede2fe9872035eaef"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; Layer::Ptr &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1tmx_1_1_map.html#a290cbb5645c6ac8ede2fe9872035eaef">getLayers</a> () const </td></tr>
<tr class="memdesc:a290cbb5645c6ac8ede2fe9872035eaef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the vector containing the layer data. Layers are pointer-to-baseclass, the concrete type of which can be found via <a class="el" href="classxy_1_1tmx_1_1_layer.html#a68b5a45e518d3258a3c82a5b4a3ef4e1" title="Returns a Type value representing the concrete type. ">Layer::getType()</a>  <a href="#a290cbb5645c6ac8ede2fe9872035eaef">More...</a><br /></td></tr>
<tr class="separator:a290cbb5645c6ac8ede2fe9872035eaef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf11e03d83380300d6a66dcef648de0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bf11e03d83380300d6a66dcef648de0"></a>
const std::vector&lt; <a class="el" href="classxy_1_1tmx_1_1_property.html">Property</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1tmx_1_1_map.html#a3bf11e03d83380300d6a66dcef648de0">getProperties</a> () const </td></tr>
<tr class="memdesc:a3bf11e03d83380300d6a66dcef648de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of <a class="el" href="classxy_1_1tmx_1_1_property.html" title="Represents a custom property. Tiles, objects and layers of a tmx may all have custom properties assig...">Property</a> objects loaded by the map. <br /></td></tr>
<tr class="separator:a3bf11e03d83380300d6a66dcef648de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8349694cec39f68fa651dc2720c1d47b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classxy_1_1_tile_map_layer.html">TileMapLayer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1tmx_1_1_map.html#a8349694cec39f68fa651dc2720c1d47b">getDrawable</a> (<a class="el" href="classxy_1_1_message_bus.html">xy::MessageBus</a> &amp;, const <a class="el" href="classxy_1_1tmx_1_1_layer.html">Layer</a> &amp;, <a class="el" href="classxy_1_1_texture_resource.html">TextureResource</a> &amp;, <a class="el" href="classxy_1_1_shader_resource.html">ShaderResource</a> &amp;)</td></tr>
<tr class="memdesc:a8349694cec39f68fa651dc2720c1d47b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a drawable component from the given layer which can be attached to a <a class="el" href="classxy_1_1_scene.html" title="Scene class. ">Scene</a> <a class="el" href="classxy_1_1_entity.html" title="Entity class. ">Entity</a>. Only <a class="el" href="classxy_1_1tmx_1_1_tile_layer.html" title="A layer made up from a series of tile sets. ">TileLayer</a> and <a class="el" href="classxy_1_1tmx_1_1_image_layer.html" title="Image layers contain a single image which make up that layer. The parser contains the fully resolved ...">ImageLayer</a> types are valid, trying to create a drawable component from an object layer will return a nullptr. Passing a reference to a layer which doesn't belong to this map will also cause a nullptr to be returned.  <a href="#a8349694cec39f68fa651dc2720c1d47b">More...</a><br /></td></tr>
<tr class="separator:a8349694cec39f68fa651dc2720c1d47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0f47a313d445b441eb1812a9270585"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f0f47a313d445b441eb1812a9270585"></a>
std::unique_ptr&lt; <a class="el" href="classxy_1_1_physics_1_1_rigid_body.html">Physics::RigidBody</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1tmx_1_1_map.html#a6f0f47a313d445b441eb1812a9270585">createRigidBody</a> (<a class="el" href="classxy_1_1_message_bus.html">xy::MessageBus</a> &amp;, const <a class="el" href="classxy_1_1tmx_1_1_layer.html">Layer</a> &amp;, Physics::BodyType=Physics::BodyType::Static)</td></tr>
<tr class="memdesc:a6f0f47a313d445b441eb1812a9270585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to create a RigidBody component from a given <a class="el" href="classxy_1_1tmx_1_1_layer.html" title="Represents a layer of a tmx format tile map. This is an abstract base class from which all layer type...">Layer</a>. This function will attempt to parse all objects in a given <a class="el" href="classxy_1_1tmx_1_1_object_group.html" title="ObjectGroup layers contain a series of Objects which may be made up of shapes or images. ">ObjectGroup</a> and attach them to a single RigidBody component. This is useful for map layers designed to contain, for example, solid collision objects. If the given layer is not an <a class="el" href="classxy_1_1tmx_1_1_object_group.html" title="ObjectGroup layers contain a series of Objects which may be made up of shapes or images. ">ObjectGroup</a> then this function returns a nullptr. <br /></td></tr>
<tr class="separator:a6f0f47a313d445b441eb1812a9270585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c0a33abfed7b919b0a34ccf9cb8fa9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8c0a33abfed7b919b0a34ccf9cb8fa9"></a>
std::unique_ptr&lt; <a class="el" href="classxy_1_1_physics_1_1_rigid_body.html">Physics::RigidBody</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1tmx_1_1_map.html#af8c0a33abfed7b919b0a34ccf9cb8fa9">createRigidBody</a> (<a class="el" href="classxy_1_1_message_bus.html">xy::MessageBus</a> &amp;, const <a class="el" href="classxy_1_1tmx_1_1_object_group.html">ObjectGroup</a> &amp;, Physics::BodyType=Physics::BodyType::Static)</td></tr>
<tr class="memdesc:af8c0a33abfed7b919b0a34ccf9cb8fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a RigidBody component from a given <a class="el" href="classxy_1_1tmx_1_1_object_group.html" title="ObjectGroup layers contain a series of Objects which may be made up of shapes or images. ">ObjectGroup</a>. This function will attempt to parse all objects in a given <a class="el" href="classxy_1_1tmx_1_1_object_group.html" title="ObjectGroup layers contain a series of Objects which may be made up of shapes or images. ">ObjectGroup</a> and attach them to a single RigidBody component. This is useful for map layers designed to contain, for example, solid collision objects. If the given <a class="el" href="classxy_1_1tmx_1_1_object_group.html" title="ObjectGroup layers contain a series of Objects which may be made up of shapes or images. ">ObjectGroup</a> is invalid then this function returns a nullptr. <br /></td></tr>
<tr class="separator:af8c0a33abfed7b919b0a34ccf9cb8fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c988c828f29db84ea9fca5573da2ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7c988c828f29db84ea9fca5573da2ea"></a>
std::unique_ptr&lt; <a class="el" href="classxy_1_1_physics_1_1_rigid_body.html">Physics::RigidBody</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1tmx_1_1_map.html#ae7c988c828f29db84ea9fca5573da2ea">createRigidBody</a> (<a class="el" href="classxy_1_1_message_bus.html">xy::MessageBus</a> &amp;, const <a class="el" href="classxy_1_1tmx_1_1_object.html">Object</a> &amp;, Physics::BodyType=Physics::BodyType::Dynamic)</td></tr>
<tr class="memdesc:ae7c988c828f29db84ea9fca5573da2ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a RigidBody component from a given object. This function attempts to create a RigidBody component from a given object, useful for dynamic items which each require their own physics body. If the function fails then it will return nullptr. <br /></td></tr>
<tr class="separator:ae7c988c828f29db84ea9fca5573da2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4abe1b93350d262086b97c92c10794f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4abe1b93350d262086b97c92c10794f"></a>
std::unique_ptr&lt; <a class="el" href="classxy_1_1_physics_1_1_collision_shape.html">Physics::CollisionShape</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1tmx_1_1_map.html#ab4abe1b93350d262086b97c92c10794f">createCollisionShape</a> (const <a class="el" href="classxy_1_1tmx_1_1_object.html">Object</a> &amp;)</td></tr>
<tr class="memdesc:ab4abe1b93350d262086b97c92c10794f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to create a CollisionShape from a given object. Collision shapes created from the given object can then be attached to arbitrary RigidBody components, and so is useful for creating template type shapes from an object on a map, for example when dynamically spawning new Entities at run time. <br /></td></tr>
<tr class="separator:ab4abe1b93350d262086b97c92c10794f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a16027aa833922b9b84250435a211660b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16027aa833922b9b84250435a211660b"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>xy::TileMapLayer</b></td></tr>
<tr class="separator:a16027aa833922b9b84250435a211660b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Parser for TMX format tile maps. This class can be used to parse the XML format tile maps created with the Tiled map editor, providing an interface to create xygine compatible Drawable and <a class="el" href="namespacexy_1_1_physics.html" title="Classes relating to xygine&#39;s physics binding. ">Physics</a> components, which can be used in a scene graph. Typical usage would be to create an instance of this class before calling <a class="el" href="classxy_1_1tmx_1_1_map.html#afa755e5d3505eeb1629d52517f159f7c" title="Attempts to parse the tilemap at the given location. ">load()</a> providing a path to the *.tmx file to load. Then layers or objects can be requested from the <a class="el" href="classxy_1_1tmx_1_1_map.html" title="Parser for TMX format tile maps. This class can be used to parse the XML format tile maps created wit...">Map</a> class to be returned as xygine components. Once the components are added to a <a class="el" href="classxy_1_1_scene.html" title="Scene class. ">Scene</a> they can be interacted with in the same way as any other xygine Entity/Component, providing a flexible interface with tile maps. </p>
<p>The class also provides direct read-only access to map data so that it may be used for any custom interpretation. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8349694cec39f68fa651dc2720c1d47b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classxy_1_1_tile_map_layer.html">TileMapLayer</a> &gt; Map::getDrawable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxy_1_1_message_bus.html">xy::MessageBus</a> &amp;&#160;</td>
          <td class="paramname"><em>mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxy_1_1tmx_1_1_layer.html">Layer</a> &amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxy_1_1_texture_resource.html">TextureResource</a> &amp;&#160;</td>
          <td class="paramname"><em>tr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxy_1_1_shader_resource.html">ShaderResource</a> &amp;&#160;</td>
          <td class="paramname"><em>sr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a drawable component from the given layer which can be attached to a <a class="el" href="classxy_1_1_scene.html" title="Scene class. ">Scene</a> <a class="el" href="classxy_1_1_entity.html" title="Entity class. ">Entity</a>. Only <a class="el" href="classxy_1_1tmx_1_1_tile_layer.html" title="A layer made up from a series of tile sets. ">TileLayer</a> and <a class="el" href="classxy_1_1tmx_1_1_image_layer.html" title="Image layers contain a single image which make up that layer. The parser contains the fully resolved ...">ImageLayer</a> types are valid, trying to create a drawable component from an object layer will return a nullptr. Passing a reference to a layer which doesn't belong to this map will also cause a nullptr to be returned. </p>
<dl class="section return"><dt>Returns</dt><dd>Drawable component if successful, else nullptr </dd></dl>

</div>
</div>
<a class="anchor" id="a290cbb5645c6ac8ede2fe9872035eaef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;Layer::Ptr&gt;&amp; xy::tmx::Map::getLayers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the vector containing the layer data. Layers are pointer-to-baseclass, the concrete type of which can be found via <a class="el" href="classxy_1_1tmx_1_1_layer.html#a68b5a45e518d3258a3c82a5b4a3ef4e1" title="Returns a Type value representing the concrete type. ">Layer::getType()</a> </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classxy_1_1tmx_1_1_layer.html" title="Represents a layer of a tmx format tile map. This is an abstract base class from which all layer type...">Layer</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afa755e5d3505eeb1629d52517f159f7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Map::load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to parse the tilemap at the given location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">std::string</td><td>Path to map file to try to parse </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if map was parsed successful else returns false. In debug mode this will attempt to log any errors to the console. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
