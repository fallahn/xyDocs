<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>xyginext: xy Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">xyginext
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
   <div id="projectbrief">Second generation of xygine game creation framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">xy Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Main xyginext namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacexy_1_1_nim"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexy_1_1_nim.html">Nim</a></td></tr>
<tr class="memdesc:namespacexy_1_1_nim"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exposes a selection of ImGui functions to the public API. These can be used to create stand-alone windows or to add useful information to the status window via App::registerStatusOutput(). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_app.html">App</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for new games or applications.  <a href="classxy_1_1_app.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_audio_emitter.html">AudioEmitter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Audio emitter component. Audio emitter provide points within the scene to play audio, either one shot effects or streaming music. If the buffer used to supply the audio is mono, and the scene contains an <a class="el" href="classxy_1_1_audio_system.html" title="Audio System. While AudioEmitter components will still be audible without and active AudioSystem...">AudioSystem</a>, then the <a class="el" href="classxy_1_1_audio_emitter.html" title="Audio emitter component. Audio emitter provide points within the scene to play audio, either one shot effects or streaming music. If the buffer used to supply the audio is mono, and the scene contains an AudioSystem, then the AudioEmitter will be panned spatially relative to the current listener (usually the active scene camera), unless it has been set to absolute positioning. ">AudioEmitter</a> will be panned spatially relative to the current listener (usually the active scene camera), unless it has been set to absolute positioning.  <a href="classxy_1_1_audio_emitter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_audio_listener.html">AudioListener</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Audio Listener component. The <a class="el" href="classxy_1_1_audio_listener.html" title="Audio Listener component. The AudioListener component defines the point at which the active AudioSyst...">AudioListener</a> component defines the point at which the active <a class="el" href="classxy_1_1_audio_system.html" title="Audio System. While AudioEmitter components will still be audible without and active AudioSystem...">AudioSystem</a> hears any playing AudioSources. Only one listener is active at a time, by default on the <a class="el" href="classxy_1_1_scene.html" title="Encapsulates a single scene. The scene class contains everything needed to create a scene graph by en...">Scene</a>'s active camera entity. When using mono AudioEmitters spatialisation is calculated based on an AudioSource's position relative to the active <a class="el" href="classxy_1_1_audio_listener.html" title="Audio Listener component. The AudioListener component defines the point at which the active AudioSyst...">AudioListener</a>.  <a href="classxy_1_1_audio_listener.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_audio_mixer.html">AudioMixer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multichannel Audio mixer class. The <a class="el" href="classxy_1_1_audio_mixer.html" title="Multichannel Audio mixer class. The AudioMixer allows AudioEmitter components to group their outputs ...">AudioMixer</a> allows <a class="el" href="classxy_1_1_audio_emitter.html" title="Audio emitter component. Audio emitter provide points within the scene to play audio, either one shot effects or streaming music. If the buffer used to supply the audio is mono, and the scene contains an AudioSystem, then the AudioEmitter will be panned spatially relative to the current listener (usually the active scene camera), unless it has been set to absolute positioning. ">AudioEmitter</a> components to group their outputs into one of 16 channels, each of which may have their volume adjusted, affecting all of the AudioEmitters currently routed through that channel. The <a class="el" href="classxy_1_1_audio_mixer.html" title="Multichannel Audio mixer class. The AudioMixer allows AudioEmitter components to group their outputs ...">AudioMixer</a> also has a master volume channel which is applied to all subsequent channels. By default <a class="el" href="classxy_1_1_audio_emitter.html" title="Audio emitter component. Audio emitter provide points within the scene to play audio, either one shot effects or streaming music. If the buffer used to supply the audio is mono, and the scene contains an AudioSystem, then the AudioEmitter will be panned spatially relative to the current listener (usually the active scene camera), unless it has been set to absolute positioning. ">AudioEmitter</a> components are assigned to channel 0. For these <a class="el" href="classxy_1_1_audio_mixer.html" title="Multichannel Audio mixer class. The AudioMixer allows AudioEmitter components to group their outputs ...">AudioMixer</a> settings to be applied a scene must have an active <a class="el" href="classxy_1_1_audio_system.html" title="Audio System. While AudioEmitter components will still be audible without and active AudioSystem...">AudioSystem</a>.  <a href="classxy_1_1_audio_mixer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_audio_system.html">AudioSystem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Audio <a class="el" href="classxy_1_1_system.html" title="Base class for systems. Systems should all derive from this base class, and instanciated before any e...">System</a>. While <a class="el" href="classxy_1_1_audio_emitter.html" title="Audio emitter component. Audio emitter provide points within the scene to play audio, either one shot effects or streaming music. If the buffer used to supply the audio is mono, and the scene contains an AudioSystem, then the AudioEmitter will be panned spatially relative to the current listener (usually the active scene camera), unless it has been set to absolute positioning. ">AudioEmitter</a> components will still be audible without and active <a class="el" href="classxy_1_1_audio_system.html" title="Audio System. While AudioEmitter components will still be audible without and active AudioSystem...">AudioSystem</a>, and <a class="el" href="classxy_1_1_audio_system.html" title="Audio System. While AudioEmitter components will still be audible without and active AudioSystem...">AudioSystem</a> instance is required in the scene to update positional audio, as well as apply the values stored in the <a class="el" href="classxy_1_1_audio_mixer.html" title="Multichannel Audio mixer class. The AudioMixer allows AudioEmitter components to group their outputs ...">AudioMixer</a>. It is, therefore, recommended that any scene which employs <a class="el" href="classxy_1_1_audio_emitter.html" title="Audio emitter component. Audio emitter provide points within the scene to play audio, either one shot effects or streaming music. If the buffer used to supply the audio is mono, and the scene contains an AudioSystem, then the AudioEmitter will be panned spatially relative to the current listener (usually the active scene camera), unless it has been set to absolute positioning. ">AudioEmitter</a> components also has an <a class="el" href="classxy_1_1_audio_system.html" title="Audio System. While AudioEmitter components will still be audible without and active AudioSystem...">AudioSystem</a>.  <a href="classxy_1_1_audio_system.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_base_resource.html">BaseResource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for resource management.  <a href="classxy_1_1_base_resource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxy_1_1_callback.html">Callback</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows attaching a callback function to an entity.  <a href="structxy_1_1_callback.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_callback_system.html">CallbackSystem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a given callback function on an entity. This is useful for behaviour code on entities which aren't used often. For example when a single entity of a type exists and is used rarely it can mean a lot of overhead writing a specific system and component for behaviour which is not often employed. In these cases it's easier to attach a <a class="el" href="structxy_1_1_callback.html" title="Allows attaching a callback function to an entity. ">Callback</a> component and supply a function with entity specific behaviour. Overuse of this system is not recommended, however, as there is a certain amount of overhead in calling the behavioural functions, so this system should be reserved for specific cases where it makes sense or for rapid prototying of ideas that may or may not be expanded to a full system.  <a href="classxy_1_1_callback_system.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_camera.html">Camera</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a 2D camera. <a class="el" href="classxy_1_1_camera.html" title="Represents a 2D camera. Camera components can be attached to entities so that they take on the transf...">Camera</a> components can be attached to entities so that they take on the transform of any transform component, and also be used to bound the game world view.  <a href="classxy_1_1_camera.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_camera_system.html">CameraSystem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The camera system updates any camera components which are attached to entities that also have a transform. Properties such as locked rotation or locked axis are applied by this system, so it needs to exist in a scene which uses any camera other than the default one.  <a href="classxy_1_1_camera_system.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxy_1_1_command.html">Command</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structxy_1_1_command.html" title="Command struct. Each command encapsulates a mask of target IDs as well as a command in the form of a ...">Command</a> struct. Each command encapsulates a mask of target IDs as well as a command in the form of a std::function.  <a href="structxy_1_1_command.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_command_system.html">CommandSystem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxy_1_1_command_target.html">CommandTarget</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a command ID bitmask to an <a class="el" href="classxy_1_1_entity.html" title="Entity class - Basically just an ID. The ID is generated as a combination of the index in the memory ...">Entity</a>. ID should be a bit mask of flags representing target IDs. For example:  <a href="structxy_1_1_command_target.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_component.html">Component</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_config_item.html">ConfigItem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all items loaded from a configuration file.  <a href="classxy_1_1_config_item.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_config_object.html">ConfigObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A configuration object can hold one or more nested objects or configuration properties. All objects require a name, and may have an optional id as a string value.  <a href="classxy_1_1_config_object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_config_property.html">ConfigProperty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Properties are a name / value pair which can only reside in configuration objects.  <a href="classxy_1_1_config_property.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_console.html">Console</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classxy_1_1_console.html" title="Console class. The console class provides a feedback window and interface with xygine. Any class can register a command with the console as long as it inherits the ConsoleClient interface. ">Console</a> class. The console class provides a feedback window and interface with xygine. Any class can register a command with the console as long as it inherits the <a class="el" href="classxy_1_1_console_client.html" title="Interface for registering console commands. To register a command with the console a class needs to i...">ConsoleClient</a> interface.  <a href="classxy_1_1_console.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_console_client.html">ConsoleClient</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for registering console commands. To register a command with the console a class needs to inherit this interface, which ensures proper lifetime of console commands which refer to specific instances of an object.  <a href="classxy_1_1_console_client.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_director.html">Director</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract Base Class for Directors. A director is an 'observer' of the scene to which it belongs, and has the ability to command, or direct entities within it. While Directors do not exist within the world, they can receive both external events, such as player input, and system messages emitted from the scene. Based on this input the <a class="el" href="classxy_1_1_director.html" title="Abstract Base Class for Directors. A director is an &#39;observer&#39; of the scene to which it belongs...">Director</a> can then use a <a class="el" href="classxy_1_1_command_system.html">CommandSystem</a> (one of which is automatically added to the scene when a <a class="el" href="classxy_1_1_director.html" title="Abstract Base Class for Directors. A director is an &#39;observer&#39; of the scene to which it belongs...">Director</a> is first added, if it does not exist) to send commands to entities within the scene. For example a <a class="el" href="classxy_1_1_director.html" title="Abstract Base Class for Directors. A director is an &#39;observer&#39; of the scene to which it belongs...">Director</a> may take player input, process it then send movement commands to a player entity. It may also be used to implement gameplay rules by using the events it has observed to decide when new enemies should be spawned, where a player should restart and so on.  <a href="classxy_1_1_director.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_drawable.html">Drawable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classxy_1_1_drawable.html" title="Drawable component. The drawable component encapsulates an sf::VertexArray which can be used to draw ...">Drawable</a> component. The drawable component encapsulates an sf::VertexArray which can be used to draw custom shapes, as well as being required for entities which have a sprite or text component. The purpose of the <a class="el" href="classxy_1_1_drawable.html" title="Drawable component. The drawable component encapsulates an sf::VertexArray which can be used to draw ...">Drawable</a> component is to allow mixing <a class="el" href="classxy_1_1_sprite.html" title="Sprite component optimised to work with the ECS. Sprite components require their entity to also have ...">Sprite</a>, <a class="el" href="classxy_1_1_text.html" title="ECS friendly implementation of Text. ">Text</a> and custom drawable types in a single drawing pass with variable depth. A <a class="el" href="classxy_1_1_scene.html" title="Encapsulates a single scene. The scene class contains everything needed to create a scene graph by en...">Scene</a> must have a <a class="el" href="classxy_1_1_render_system.html" title="Used to draw all entities which have a Drawable and Transform component. The RenderSystem is used to ...">RenderSystem</a> added to it to enable any drawable entities.  <a href="classxy_1_1_drawable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxy_1_1_emitter_settings.html">EmitterSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Settings used by a particle emitter to initialise new particles.  <a href="structxy_1_1_emitter_settings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_enet_client_impl.html">EnetClientImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default networking library implmentation. This should never be used directly.  <a href="classxy_1_1_enet_client_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_enet_host_impl.html">EnetHostImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of the networking library. This should never be used directly.  <a href="classxy_1_1_enet_host_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_entity.html">Entity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classxy_1_1_entity.html" title="Entity class - Basically just an ID. The ID is generated as a combination of the index in the memory ...">Entity</a> class - Basically just an ID. The ID is generated as a combination of the index in the memory pool and the generation - that is the nth time the index has been used.  <a href="classxy_1_1_entity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_entity_manager.html">EntityManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages the relationship between an <a class="el" href="classxy_1_1_entity.html" title="Entity class - Basically just an ID. The ID is generated as a combination of the index in the memory ...">Entity</a> and its components.  <a href="classxy_1_1_entity_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_file_system.html">FileSystem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utilities for manipulating the current file system.  <a href="classxy_1_1_file_system.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_font_resource.html">FontResource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resource manager for Fonts.  <a href="classxy_1_1_font_resource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_gui_client.html">GuiClient</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows registering GUI controls with the default output window, or registering custom windows using the <a class="el" href="namespacexy_1_1_nim.html" title="Exposes a selection of ImGui functions to the public API. These can be used to create stand-alone win...">Nim</a> namespace. Classes which inherit this interface may register controls with the imgui renderer. This is usually used for debugging output or when creating tooling.  <a href="classxy_1_1_gui_client.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_image_resource.html">ImageResource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resource manager for sf::Image types.  <a href="classxy_1_1_image_resource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_interpolation_system.html">InterpolationSystem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the <a class="el" href="classxy_1_1_net_interpolate.html" title="Interpolates positions received from a server. When receiving infrequent (say 100ms or so) position u...">NetInterpolate</a> component to linearly interpolate a transform component's position between two points.  <a href="classxy_1_1_interpolation_system.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_logger.html">Logger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to allowing messages to be logged to a combination of one or more destinations such as the console, log file or output window in Visual Studio.  <a href="classxy_1_1_logger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_message.html">Message</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classxy_1_1_message.html" title="Message class. ">Message</a> class.  <a href="classxy_1_1_message.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_message_bus.html">MessageBus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classxy_1_1_system.html" title="Base class for systems. Systems should all derive from this base class, and instanciated before any e...">System</a> wide message bus for custom event messaging.  <a href="classxy_1_1_message_bus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_net_client.html">NetClient</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clientside host which can be used to create a peer connected to a <a class="el" href="classxy_1_1_net_host.html" title="Creates a network host. Network hosts, or servers, can have multiple clients connected to them...">NetHost</a> server.  <a href="classxy_1_1_net_client.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_net_client_impl.html">NetClientImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxy_1_1_net_event.html">NetEvent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Network event. These are used to poll <a class="el" href="classxy_1_1_net_host.html" title="Creates a network host. Network hosts, or servers, can have multiple clients connected to them...">NetHost</a> and <a class="el" href="classxy_1_1_net_client.html" title="Creates a clientside host which can be used to create a peer connected to a NetHost server...">NetClient</a> objects for network activity.  <a href="structxy_1_1_net_event.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_net_host.html">NetHost</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a network host. Network hosts, or servers, can have multiple clients connected to them, via a reliable UDP stream.  <a href="classxy_1_1_net_host.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_net_host_impl.html">NetHostImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_net_interpolate.html">NetInterpolate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates positions received from a server. When receiving infrequent (say 100ms or so) position updates from a remote server entities can have their position interpolated via this component. The component, when coupled with an <a class="el" href="classxy_1_1_interpolation_system.html" title="Uses the NetInterpolate component to linearly interpolate a transform component&#39;s position between tw...">InterpolationSystem</a> will travel towards the given target position using the given timestamp to linearly interpolate movement. This component is not limited to networked entities, and can be used anywhere linear interpolation of movement is desired.  <a href="classxy_1_1_net_interpolate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxy_1_1_net_peer.html">NetPeer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A peer represents a single, multichannel connection between a client and a host.  <a href="structxy_1_1_net_peer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxy_1_1_particle.html">Particle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a single particle in a system.  <a href="structxy_1_1_particle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_particle_emitter.html">ParticleEmitter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structxy_1_1_particle.html" title="Represents a single particle in a system. ">Particle</a> Emitter. <a class="el" href="classxy_1_1_component.html">Component</a> struct used to emit particles from an entity.  <a href="classxy_1_1_particle_emitter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_particle_system.html">ParticleSystem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classxy_1_1_particle_system.html" title="ParticleSystem. Responsible for updating all ParticelEmitter components in the scene, and rendering the output. ">ParticleSystem</a>. Responsible for updating all ParticelEmitter components in the scene, and rendering the output.  <a href="classxy_1_1_particle_system.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_post_antique.html">PostAntique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Antique Post process effect. Creates an old 'filmic' look, with dust, jitter and desaturation.  <a href="classxy_1_1_post_antique.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_post_bloom.html">PostBloom</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bloom post process effect.  <a href="classxy_1_1_post_bloom.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_post_blur.html">PostBlur</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post process effect which applies a screen-wide gaussian blur. This effect can be enabled and disabled as needed via direct call to <a class="el" href="classxy_1_1_post_blur.html#a7ecc3cea360f73ac1f197078df9c5a53" title="Enables or disables the blur effect. By default this is disabled, so call this at least once if no bl...">setEnabled()</a>. Blur amount is animated when enabling or disabling for a smoother transition.  <a href="classxy_1_1_post_blur.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_post_chrome_ab.html">PostChromeAb</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Chromatic Abberation effect.  <a href="classxy_1_1_post_chrome_ab.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_post_old_school.html">PostOldSchool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a colour dithering / degredation effect to emulate the appearance of older 16 or 8 bit graphics modes.  <a href="classxy_1_1_post_old_school.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_post_process.html">PostProcess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for full screen post processes.  <a href="classxy_1_1_post_process.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_quad_tree.html">QuadTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition system for entities with <a class="el" href="classxy_1_1_quad_tree_item.html" title="Entities with a QuadTreeItem and Transform component will be actively partitioned an in QuadTree syst...">QuadTreeItem</a> components. Entities are sorted in a tree hierarchy which can be queried with a given area to return a set of entities which are contained or intersect said area.  <a href="classxy_1_1_quad_tree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_quad_tree_item.html">QuadTreeItem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entities with a <a class="el" href="classxy_1_1_quad_tree_item.html" title="Entities with a QuadTreeItem and Transform component will be actively partitioned an in QuadTree syst...">QuadTreeItem</a> and <a class="el" href="classxy_1_1_transform.html" title="Wraps the SFML transformable class in a component friendly format, parentable to other transforms in ...">Transform</a> component will be actively partitioned an in <a class="el" href="classxy_1_1_quad_tree.html" title="Partition system for entities with QuadTreeItem components. Entities are sorted in a tree hierarchy w...">QuadTree</a> system which is added to the entities scene.  <a href="classxy_1_1_quad_tree_item.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_quad_tree_node.html">QuadTreeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nodes which make up the branches and leaves of the <a class="el" href="classxy_1_1_quad_tree.html" title="Partition system for entities with QuadTreeItem components. Entities are sorted in a tree hierarchy w...">QuadTree</a>.  <a href="classxy_1_1_quad_tree_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_render_system.html">RenderSystem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to draw all entities which have a <a class="el" href="classxy_1_1_drawable.html" title="Drawable component. The drawable component encapsulates an sf::VertexArray which can be used to draw ...">Drawable</a> and <a class="el" href="classxy_1_1_transform.html" title="Wraps the SFML transformable class in a component friendly format, parentable to other transforms in ...">Transform</a> component. The <a class="el" href="classxy_1_1_render_system.html" title="Used to draw all entities which have a Drawable and Transform component. The RenderSystem is used to ...">RenderSystem</a> is used to depth sort and draw all entities which have a <a class="el" href="classxy_1_1_drawable.html" title="Drawable component. The drawable component encapsulates an sf::VertexArray which can be used to draw ...">Drawable</a> and <a class="el" href="classxy_1_1_transform.html" title="Wraps the SFML transformable class in a component friendly format, parentable to other transforms in ...">Transform</a> component attached, and optionally a <a class="el" href="classxy_1_1_sprite.html" title="Sprite component optimised to work with the ECS. Sprite components require their entity to also have ...">Sprite</a> component. NOTE multiple components which rely on a <a class="el" href="classxy_1_1_drawable.html" title="Drawable component. The drawable component encapsulates an sf::VertexArray which can be used to draw ...">Drawable</a> component cannot exist on the same entity, as only one set of vertices will be available.  <a href="classxy_1_1_render_system.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_scene.html">Scene</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates a single scene. The scene class contains everything needed to create a scene graph by encapsulating the ECS and providing factory functions for entities. Multple scenes can exist at one time, for instance one to draw the game world, and another to draw the HUD. Everything is rendered through renderable systems which, in turn, require an ECS - therefore every state which wishes to draw something requires at least a scene, right down to menus. All systems should be added before attempting to create any entities else existing entities will not be processed by new systems.  <a href="classxy_1_1_scene.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_shader_resource.html">ShaderResource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialised resource manager for shaders.  <a href="classxy_1_1_shader_resource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_sound_resource.html">SoundResource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resource manager for sound files.  <a href="classxy_1_1_sound_resource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_sprite.html">Sprite</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classxy_1_1_sprite.html" title="Sprite component optimised to work with the ECS. Sprite components require their entity to also have ...">Sprite</a> component optimised to work with the ECS. <a class="el" href="classxy_1_1_sprite.html" title="Sprite component optimised to work with the ECS. Sprite components require their entity to also have ...">Sprite</a> components require their entity to also have a <a class="el" href="classxy_1_1_drawable.html" title="Drawable component. The drawable component encapsulates an sf::VertexArray which can be used to draw ...">Drawable</a> component.  <a href="classxy_1_1_sprite.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxy_1_1_sprite_animation.html">SpriteAnimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classxy_1_1_component.html">Component</a> which contains information about the currently playing sprite animation. Requires a <a class="el" href="classxy_1_1_sprite_animator.html" title="Sprite Animation system. Updates all active animations on entities which have Sprite and SpriteAnimat...">SpriteAnimator</a> system in the scene.  <a href="structxy_1_1_sprite_animation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_sprite_animator.html">SpriteAnimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classxy_1_1_sprite.html" title="Sprite component optimised to work with the ECS. Sprite components require their entity to also have ...">Sprite</a> Animation system. Updates all active animations on entities which have <a class="el" href="classxy_1_1_sprite.html" title="Sprite component optimised to work with the ECS. Sprite components require their entity to also have ...">Sprite</a> and <a class="el" href="structxy_1_1_sprite_animation.html" title="Component which contains information about the currently playing sprite animation. Requires a SpriteAnimator system in the scene. ">SpriteAnimation</a> components.  <a href="classxy_1_1_sprite_animator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_sprite_sheet.html">SpriteSheet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supports loading multiple sprites from a single texture atlas via the ConfigFile format.  <a href="classxy_1_1_sprite_sheet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_sprite_system.html">SpriteSystem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classxy_1_1_system.html" title="Base class for systems. Systems should all derive from this base class, and instanciated before any e...">System</a> for updating sprites. Entities with <a class="el" href="classxy_1_1_sprite.html" title="Sprite component optimised to work with the ECS. Sprite components require their entity to also have ...">Sprite</a> components also require a <a class="el" href="classxy_1_1_drawable.html" title="Drawable component. The drawable component encapsulates an sf::VertexArray which can be used to draw ...">Drawable</a> component, as well as a <a class="el" href="classxy_1_1_scene.html" title="Encapsulates a single scene. The scene class contains everything needed to create a scene graph by en...">Scene</a> with a <a class="el" href="classxy_1_1_render_system.html" title="Used to draw all entities which have a Drawable and Transform component. The RenderSystem is used to ...">RenderSystem</a>.  <a href="classxy_1_1_sprite_system.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_state.html">State</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for xygine states.  <a href="classxy_1_1_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_state_stack.html">StateStack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maintains a stack of active states.  <a href="classxy_1_1_state_stack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_system.html">System</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for systems. Systems should all derive from this base class, and instanciated before any entities are created. Concrete system types should declare a list component types via <a class="el" href="classxy_1_1_system.html#a07c94f83c2346844be4e568c9d78823b" title="Adds a component type to the list of components required by the system for it to be interested in a p...">requireComponent()</a> on construction, so that only entities with the relevant components are added to the system.  <a href="classxy_1_1_system.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_system_manager.html">SystemManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_sys_time.html">SysTime</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static functions for common date/time queries using the system clock.  <a href="classxy_1_1_sys_time.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_text.html">Text</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECS friendly implementation of <a class="el" href="classxy_1_1_text.html" title="ECS friendly implementation of Text. ">Text</a>.  <a href="classxy_1_1_text.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_text_renderer.html">TextRenderer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classxy_1_1_system.html" title="Base class for systems. Systems should all derive from this base class, and instanciated before any e...">System</a> for rendering text objects. Usually this would be added last to the <a class="el" href="classxy_1_1_scene.html" title="Encapsulates a single scene. The scene class contains everything needed to create a scene graph by en...">Scene</a> after existing drawable systems, as the text ought to be rendered on top of everything else.  <a href="classxy_1_1_text_renderer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_texture_resource.html">TextureResource</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resource manager for textures.  <a href="classxy_1_1_texture_resource.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_transform.html">Transform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the SFML transformable class in a component friendly format, parentable to other transforms in a scene graph hierachy. Transforms are non-copyable, but are moveable.  <a href="classxy_1_1_transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_u_i_hit_box.html">UIHitBox</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to trigger callbacks when hit events occur in the component's area.  <a href="classxy_1_1_u_i_hit_box.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_u_i_system.html">UISystem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates entities with <a class="el" href="classxy_1_1_u_i_hit_box.html" title="Used to trigger callbacks when hit events occur in the component&#39;s area. ">UIHitBox</a> components. Any entity with a <a class="el" href="classxy_1_1_u_i_hit_box.html" title="Used to trigger callbacks when hit events occur in the component&#39;s area. ">UIHitBox</a> component will be processed by this system, which detects user input and activates the appropriate callback as necessary.  <a href="classxy_1_1_u_i_system.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_vector4.html">Vector4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">4 component vector class. Useful when storing floating point colour values, particularly with ConfigFile objects  <a href="classxy_1_1_vector4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab8d7e48c908f51d8210bed3f5ebb2776"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8d7e48c908f51d8210bed3f5ebb2776"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ConfigFile</b> = <a class="el" href="classxy_1_1_config_object.html">xy::ConfigObject</a></td></tr>
<tr class="separator:ab8d7e48c908f51d8210bed3f5ebb2776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c2edc20b2509b773e65ad3bf041f58"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18c2edc20b2509b773e65ad3bf041f58"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>StateID</b> = sf::Int32</td></tr>
<tr class="separator:a18c2edc20b2509b773e65ad3bf041f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00dc89763f7d5f6d603d8c044c660d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad00dc89763f7d5f6d603d8c044c660d0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Vector4i</b> = <a class="el" href="classxy_1_1_vector4.html">Vector4</a>&lt; int &gt;</td></tr>
<tr class="separator:ad00dc89763f7d5f6d603d8c044c660d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee23ed5db5d9b1aeaea9b3d00b7a9ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acee23ed5db5d9b1aeaea9b3d00b7a9ca"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Vector4f</b> = <a class="el" href="classxy_1_1_vector4.html">Vector4</a>&lt; float &gt;</td></tr>
<tr class="separator:acee23ed5db5d9b1aeaea9b3d00b7a9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1c6b7b08f2d9821b1892b26eaf4d0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d1c6b7b08f2d9821b1892b26eaf4d0f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CallbackFunction</b> = std::function&lt; void(<a class="el" href="classxy_1_1_entity.html">Entity</a>, float)&gt;</td></tr>
<tr class="separator:a8d1c6b7b08f2d9821b1892b26eaf4d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6d6194829f7131e38f68477e362a17"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f6d6194829f7131e38f68477e362a17"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ComponentMask</b> = std::bitset&lt; Detail::MaxComponents &gt;</td></tr>
<tr class="separator:a5f6d6194829f7131e38f68477e362a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7291595f0916750b79173b937c50dbd6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7291595f0916750b79173b937c50dbd6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>UniqueType</b> = std::type_index</td></tr>
<tr class="separator:a7291595f0916750b79173b937c50dbd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a05dcce851ad31fdc5bf3179c20b19437"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexy.html#a05dcce851ad31fdc5bf3179c20b19437">NetFlag</a> { <b>Reliable</b> = 0x1, 
<a class="el" href="namespacexy.html#a05dcce851ad31fdc5bf3179c20b19437ae5cf566e2aefa539faf97b4843a0ad80">NetFlag::Unsequenced</a> = 0x2, 
<a class="el" href="namespacexy.html#a05dcce851ad31fdc5bf3179c20b19437a98a19ff88f463baefac152f8641dea36">NetFlag::Unreliable</a> = 0x4
 }<tr class="memdesc:a05dcce851ad31fdc5bf3179c20b19437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reliability enum. These are used to flag sent packets with a requested reliability.  <a href="namespacexy.html#a05dcce851ad31fdc5bf3179c20b19437">More...</a><br /></td></tr>
<tr class="separator:a05dcce851ad31fdc5bf3179c20b19437"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a506ff38a6fad0da7163088d18c054211"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a506ff38a6fad0da7163088d18c054211"></a>
static const sf::Vector2f&#160;</td><td class="memItemRight" valign="bottom"><b>DefaultSceneSize</b> (1920.f, 1080.f)</td></tr>
<tr class="separator:a506ff38a6fad0da7163088d18c054211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab902ffdae8a472d821342dbdf9ee6728"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab902ffdae8a472d821342dbdf9ee6728"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ab902ffdae8a472d821342dbdf9ee6728"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConfigProperty::getValue&lt; std::string &gt;</b> () const </td></tr>
<tr class="separator:ab902ffdae8a472d821342dbdf9ee6728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631c9e37df97ddbb723cfa358d9436d7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a631c9e37df97ddbb723cfa358d9436d7"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a631c9e37df97ddbb723cfa358d9436d7"><td class="memTemplItemLeft" align="right" valign="top">sf::Int32&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConfigProperty::getValue&lt; sf::Int32 &gt;</b> () const </td></tr>
<tr class="separator:a631c9e37df97ddbb723cfa358d9436d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840f7d3e01509a6b8a6213c8894dc1f7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a840f7d3e01509a6b8a6213c8894dc1f7"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a840f7d3e01509a6b8a6213c8894dc1f7"><td class="memTemplItemLeft" align="right" valign="top">sf::Vector2f&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConfigProperty::getValue&lt; sf::Vector2f &gt;</b> () const </td></tr>
<tr class="separator:a840f7d3e01509a6b8a6213c8894dc1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cfdd9d11648a362810274fd475d1c8"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac0cfdd9d11648a362810274fd475d1c8"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac0cfdd9d11648a362810274fd475d1c8"><td class="memTemplItemLeft" align="right" valign="top">sf::Vector3f&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConfigProperty::getValue&lt; sf::Vector3f &gt;</b> () const </td></tr>
<tr class="separator:ac0cfdd9d11648a362810274fd475d1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057b2011056114f4a5e53c713706abb1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a057b2011056114f4a5e53c713706abb1"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a057b2011056114f4a5e53c713706abb1"><td class="memTemplItemLeft" align="right" valign="top">sf::FloatRect&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConfigProperty::getValue&lt; sf::FloatRect &gt;</b> () const </td></tr>
<tr class="separator:a057b2011056114f4a5e53c713706abb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053879d77b06e5dacb50d4b16d7faa31"><td class="memTemplParams" colspan="2"><a class="anchor" id="a053879d77b06e5dacb50d4b16d7faa31"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a053879d77b06e5dacb50d4b16d7faa31"><td class="memTemplItemLeft" align="right" valign="top">sf::Color&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConfigProperty::getValue&lt; sf::Color &gt;</b> () const </td></tr>
<tr class="separator:a053879d77b06e5dacb50d4b16d7faa31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af232f592949147c9e3bef761c517806e"><td class="memTemplParams" colspan="2"><a class="anchor" id="af232f592949147c9e3bef761c517806e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af232f592949147c9e3bef761c517806e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxy_1_1_vector4.html">xy::Vector4f</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConfigProperty::getValue&lt; xy::Vector4f &gt;</b> () const </td></tr>
<tr class="separator:af232f592949147c9e3bef761c517806e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63cd3ee6d41591c2be2deb4f33d573eb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a63cd3ee6d41591c2be2deb4f33d573eb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a63cd3ee6d41591c2be2deb4f33d573eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxy_1_1_vector4.html">Vector4</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexy.html#a63cd3ee6d41591c2be2deb4f33d573eb">operator-</a> (const <a class="el" href="classxy_1_1_vector4.html">Vector4</a>&lt; T &gt; &amp;left)</td></tr>
<tr class="memdesc:a63cd3ee6d41591c2be2deb4f33d573eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of unary operator -. <br /></td></tr>
<tr class="separator:a63cd3ee6d41591c2be2deb4f33d573eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306457d2a84e8d02d994bda644c90fe3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a306457d2a84e8d02d994bda644c90fe3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a306457d2a84e8d02d994bda644c90fe3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxy_1_1_vector4.html">Vector4</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexy.html#a306457d2a84e8d02d994bda644c90fe3">operator+=</a> (<a class="el" href="classxy_1_1_vector4.html">Vector4</a>&lt; T &gt; &amp;left, const <a class="el" href="classxy_1_1_vector4.html">Vector4</a>&lt; T &gt; &amp;right)</td></tr>
<tr class="memdesc:a306457d2a84e8d02d994bda644c90fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of binary operator +=. <br /></td></tr>
<tr class="separator:a306457d2a84e8d02d994bda644c90fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371f977c3ed21ea6f73a68e34b8675f3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a371f977c3ed21ea6f73a68e34b8675f3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a371f977c3ed21ea6f73a68e34b8675f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxy_1_1_vector4.html">Vector4</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexy.html#a371f977c3ed21ea6f73a68e34b8675f3">operator-=</a> (<a class="el" href="classxy_1_1_vector4.html">Vector4</a>&lt; T &gt; &amp;left, const <a class="el" href="classxy_1_1_vector4.html">Vector4</a>&lt; T &gt; &amp;right)</td></tr>
<tr class="memdesc:a371f977c3ed21ea6f73a68e34b8675f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of binary operator -=. <br /></td></tr>
<tr class="separator:a371f977c3ed21ea6f73a68e34b8675f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b45fe699c8e71b7b26a0f2683d6f0a"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae3b45fe699c8e71b7b26a0f2683d6f0a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae3b45fe699c8e71b7b26a0f2683d6f0a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxy_1_1_vector4.html">Vector4</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexy.html#ae3b45fe699c8e71b7b26a0f2683d6f0a">operator+</a> (const <a class="el" href="classxy_1_1_vector4.html">Vector4</a>&lt; T &gt; &amp;left, const <a class="el" href="classxy_1_1_vector4.html">Vector4</a>&lt; T &gt; &amp;right)</td></tr>
<tr class="memdesc:ae3b45fe699c8e71b7b26a0f2683d6f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of binary operator +. <br /></td></tr>
<tr class="separator:ae3b45fe699c8e71b7b26a0f2683d6f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea48053b1039704f169dfc0baa4c79c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6ea48053b1039704f169dfc0baa4c79c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6ea48053b1039704f169dfc0baa4c79c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxy_1_1_vector4.html">Vector4</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexy.html#a6ea48053b1039704f169dfc0baa4c79c">operator-</a> (const <a class="el" href="classxy_1_1_vector4.html">Vector4</a>&lt; T &gt; &amp;left, const <a class="el" href="classxy_1_1_vector4.html">Vector4</a>&lt; T &gt; &amp;right)</td></tr>
<tr class="memdesc:a6ea48053b1039704f169dfc0baa4c79c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of binary operator -. <br /></td></tr>
<tr class="separator:a6ea48053b1039704f169dfc0baa4c79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7485ca52c6f47d8c9fff661a587a11"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9e7485ca52c6f47d8c9fff661a587a11"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9e7485ca52c6f47d8c9fff661a587a11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxy_1_1_vector4.html">Vector4</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexy.html#a9e7485ca52c6f47d8c9fff661a587a11">operator*</a> (const <a class="el" href="classxy_1_1_vector4.html">Vector4</a>&lt; T &gt; &amp;left, T right)</td></tr>
<tr class="memdesc:a9e7485ca52c6f47d8c9fff661a587a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of binary operator *. <br /></td></tr>
<tr class="separator:a9e7485ca52c6f47d8c9fff661a587a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1149877fcdaeecda05fe26197b9493c4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1149877fcdaeecda05fe26197b9493c4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1149877fcdaeecda05fe26197b9493c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxy_1_1_vector4.html">Vector4</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexy.html#a1149877fcdaeecda05fe26197b9493c4">operator*</a> (T left, const <a class="el" href="classxy_1_1_vector4.html">Vector4</a>&lt; T &gt; &amp;right)</td></tr>
<tr class="memdesc:a1149877fcdaeecda05fe26197b9493c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of binary operator *. <br /></td></tr>
<tr class="separator:a1149877fcdaeecda05fe26197b9493c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99581732170e4d2cb9221de9a539e7a"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae99581732170e4d2cb9221de9a539e7a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae99581732170e4d2cb9221de9a539e7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxy_1_1_vector4.html">Vector4</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexy.html#ae99581732170e4d2cb9221de9a539e7a">operator*=</a> (<a class="el" href="classxy_1_1_vector4.html">Vector4</a>&lt; T &gt; &amp;left, T right)</td></tr>
<tr class="memdesc:ae99581732170e4d2cb9221de9a539e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of binary operator *=. <br /></td></tr>
<tr class="separator:ae99581732170e4d2cb9221de9a539e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44d43d44e5320ea5bde7c9a33b88925"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa44d43d44e5320ea5bde7c9a33b88925"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa44d43d44e5320ea5bde7c9a33b88925"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxy_1_1_vector4.html">Vector4</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexy.html#aa44d43d44e5320ea5bde7c9a33b88925">operator/</a> (const <a class="el" href="classxy_1_1_vector4.html">Vector4</a>&lt; T &gt; &amp;left, T right)</td></tr>
<tr class="memdesc:aa44d43d44e5320ea5bde7c9a33b88925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of binary operator /. <br /></td></tr>
<tr class="separator:aa44d43d44e5320ea5bde7c9a33b88925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8be27b6ac322940a3e1c53d6927ea8a"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae8be27b6ac322940a3e1c53d6927ea8a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae8be27b6ac322940a3e1c53d6927ea8a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxy_1_1_vector4.html">Vector4</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexy.html#ae8be27b6ac322940a3e1c53d6927ea8a">operator/=</a> (<a class="el" href="classxy_1_1_vector4.html">Vector4</a>&lt; T &gt; &amp;left, T right)</td></tr>
<tr class="memdesc:ae8be27b6ac322940a3e1c53d6927ea8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of binary operator /=. <br /></td></tr>
<tr class="separator:ae8be27b6ac322940a3e1c53d6927ea8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750c594c24472d7e0e80acd60bc5377d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a750c594c24472d7e0e80acd60bc5377d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a750c594c24472d7e0e80acd60bc5377d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexy.html#a750c594c24472d7e0e80acd60bc5377d">operator==</a> (const <a class="el" href="classxy_1_1_vector4.html">Vector4</a>&lt; T &gt; &amp;left, const <a class="el" href="classxy_1_1_vector4.html">Vector4</a>&lt; T &gt; &amp;right)</td></tr>
<tr class="memdesc:a750c594c24472d7e0e80acd60bc5377d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of binary operator ==. <br /></td></tr>
<tr class="separator:a750c594c24472d7e0e80acd60bc5377d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b891403bdce197655b9d50eb939c8d0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6b891403bdce197655b9d50eb939c8d0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6b891403bdce197655b9d50eb939c8d0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexy.html#a6b891403bdce197655b9d50eb939c8d0">operator!=</a> (const <a class="el" href="classxy_1_1_vector4.html">Vector4</a>&lt; T &gt; &amp;left, const <a class="el" href="classxy_1_1_vector4.html">Vector4</a>&lt; T &gt; &amp;right)</td></tr>
<tr class="memdesc:a6b891403bdce197655b9d50eb939c8d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of binary operator !=. <br /></td></tr>
<tr class="separator:a6b891403bdce197655b9d50eb939c8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main xyginext namespace. </p>
<p>/brief Interface for networking implementations. By default the networking classes wrap the enet library, although in some cases it may be desirable to use 3rd party networking such as that available in the Steam API. This interface is designed to allow flexible switching of services. For <a class="el" href="classxy_1_1_net_client.html" title="Creates a clientside host which can be used to create a peer connected to a NetHost server...">NetClient</a> and <a class="el" href="classxy_1_1_net_host.html" title="Creates a network host. Network hosts, or servers, can have multiple clients connected to them...">NetHost</a> the type can be provided by the create&lt;T&gt;() and start&lt;T&gt;() functions respectively. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a05dcce851ad31fdc5bf3179c20b19437"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacexy.html#a05dcce851ad31fdc5bf3179c20b19437">xy::NetFlag</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reliability enum. These are used to flag sent packets with a requested reliability. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a05dcce851ad31fdc5bf3179c20b19437ae5cf566e2aefa539faf97b4843a0ad80"></a>Unsequenced&#160;</td><td class="fielddoc">
<p>&lt;packet must be received by the remote connection, and resend attemps are made until delivered </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a05dcce851ad31fdc5bf3179c20b19437a98a19ff88f463baefac152f8641dea36"></a>Unreliable&#160;</td><td class="fielddoc">
<p>&lt;packet will not be sequenced with other packets. Not supported on reliable packets </p>
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
