<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>xygine: xy::MultiRenderTexture Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">xygine
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">SFML Based 2D Game Creation Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacexy.html">xy</a></li><li class="navelem"><a class="el" href="classxy_1_1_multi_render_texture.html">MultiRenderTexture</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classxy_1_1_multi_render_texture-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">xy::MultiRenderTexture Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>An off-screen render target which can draw on multiple textures at once.  
 <a href="classxy_1_1_multi_render_texture.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_multi_render_texture_8hpp_source.html">MultiRenderTexture.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for xy::MultiRenderTexture:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classxy_1_1_multi_render_texture.png" usemap="#xy::MultiRenderTexture_map" alt=""/>
  <map id="xy::MultiRenderTexture_map" name="xy::MultiRenderTexture_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae5fd31b0012c73b148fca784655a56d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5fd31b0012c73b148fca784655a56d9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_multi_render_texture.html#ae5fd31b0012c73b148fca784655a56d9">MultiRenderTexture</a> ()</td></tr>
<tr class="memdesc:ae5fd31b0012c73b148fca784655a56d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. The MRT is empty and invalid until <a class="el" href="classxy_1_1_multi_render_texture.html#a07638210764610825e23a7ba3fa98821" title="Creates the MultiRenderTexture. By default MRTs are empty and invalid and this function must first be...">create()</a> is called. <br /></td></tr>
<tr class="separator:ae5fd31b0012c73b148fca784655a56d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07638210764610825e23a7ba3fa98821"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_multi_render_texture.html#a07638210764610825e23a7ba3fa98821">create</a> (sf::Uint32 width, sf::Uint32 height, sf::Uint32 count, bool depthbuffer=false, bool depthTexture=false)</td></tr>
<tr class="memdesc:a07638210764610825e23a7ba3fa98821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the <a class="el" href="classxy_1_1_multi_render_texture.html" title="An off-screen render target which can draw on multiple textures at once. ">MultiRenderTexture</a>. By default MRTs are empty and invalid and this function must first be called before the MRT can be used. Currently all of the textures created in the MRT have the same parameter, width, height, colour depth etc.  <a href="#a07638210764610825e23a7ba3fa98821">More...</a><br /></td></tr>
<tr class="separator:a07638210764610825e23a7ba3fa98821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c457dfa51d2e2da2c5a2f6ab7905cb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a59c457dfa51d2e2da2c5a2f6ab7905cb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a59c457dfa51d2e2da2c5a2f6ab7905cb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxy_1_1_multi_render_texture.html#a59c457dfa51d2e2da2c5a2f6ab7905cb">create</a> (sf::Uint32 width, sf::Uint32 height, T count, bool depthbuffer=false, bool depthTexture=false)=delete</td></tr>
<tr class="memdesc:a59c457dfa51d2e2da2c5a2f6ab7905cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevents implicitly converting bool to int when inadvertantly missing out the count parameter. <br /></td></tr>
<tr class="separator:a59c457dfa51d2e2da2c5a2f6ab7905cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370e4af7338ff96fbc65bbbeb62ff213"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a370e4af7338ff96fbc65bbbeb62ff213"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_multi_render_texture.html#a370e4af7338ff96fbc65bbbeb62ff213">setSmooth</a> (bool)</td></tr>
<tr class="memdesc:a370e4af7338ff96fbc65bbbeb62ff213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables texture smoothing. This is false by default. <br /></td></tr>
<tr class="separator:a370e4af7338ff96fbc65bbbeb62ff213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2de06e44cebde83e792340306d5db46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2de06e44cebde83e792340306d5db46"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_multi_render_texture.html#ae2de06e44cebde83e792340306d5db46">isSmooth</a> () const </td></tr>
<tr class="memdesc:ae2de06e44cebde83e792340306d5db46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if smoothing is enabled, else returns false. <br /></td></tr>
<tr class="separator:ae2de06e44cebde83e792340306d5db46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a284585e268fb9b0a5b0aca7ac52113a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a284585e268fb9b0a5b0aca7ac52113a3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_multi_render_texture.html#a284585e268fb9b0a5b0aca7ac52113a3">setRepeated</a> (bool)</td></tr>
<tr class="memdesc:a284585e268fb9b0a5b0aca7ac52113a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable texture repeating. This is false by default. <br /></td></tr>
<tr class="separator:a284585e268fb9b0a5b0aca7ac52113a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ed6b77eacf6cd16a474ad337550ec9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0ed6b77eacf6cd16a474ad337550ec9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_multi_render_texture.html#aa0ed6b77eacf6cd16a474ad337550ec9">isRepeated</a> () const </td></tr>
<tr class="memdesc:aa0ed6b77eacf6cd16a474ad337550ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if texture repeating is enabled, else returns false. <br /></td></tr>
<tr class="separator:aa0ed6b77eacf6cd16a474ad337550ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2411aed316ecd06e6124d40c358809d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_multi_render_texture.html#a2411aed316ecd06e6124d40c358809d6">setActive</a> (bool active=true)</td></tr>
<tr class="memdesc:a2411aed316ecd06e6124d40c358809d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate or deactivate the MRT for rendering.  <a href="#a2411aed316ecd06e6124d40c358809d6">More...</a><br /></td></tr>
<tr class="separator:a2411aed316ecd06e6124d40c358809d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e7a286f881c5d51a09afe82c1ac663"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7e7a286f881c5d51a09afe82c1ac663"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_multi_render_texture.html#ad7e7a286f881c5d51a09afe82c1ac663">display</a> ()</td></tr>
<tr class="memdesc:ad7e7a286f881c5d51a09afe82c1ac663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the contents of the MRT once drawing is completed. As sf::RenderWindow and sf::RenderTarget this must be called each time drawing has been completed to properly update the MRT. <br /></td></tr>
<tr class="separator:ad7e7a286f881c5d51a09afe82c1ac663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaef1dc6ea989d8ac957b64547210aed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afaef1dc6ea989d8ac957b64547210aed"></a>
sf::Vector2u&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_multi_render_texture.html#afaef1dc6ea989d8ac957b64547210aed">getSize</a> () const  override</td></tr>
<tr class="memdesc:afaef1dc6ea989d8ac957b64547210aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the MRT, as it was passed in <a class="el" href="classxy_1_1_multi_render_texture.html#a07638210764610825e23a7ba3fa98821" title="Creates the MultiRenderTexture. By default MRTs are empty and invalid and this function must first be...">create()</a> <br /></td></tr>
<tr class="separator:afaef1dc6ea989d8ac957b64547210aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa596605832739ec4ab5ec33f7a0e6dba"><td class="memItemLeft" align="right" valign="top">const sf::Texture &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_multi_render_texture.html#aa596605832739ec4ab5ec33f7a0e6dba">getTexture</a> (std::size_t index) const </td></tr>
<tr class="memdesc:aa596605832739ec4ab5ec33f7a0e6dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only reference to the texture at the given index. Once the MRT has been drawn on and updated a texture can be retrieved and used with a sf::Sprite for example, or as a uniform parameter of a shader.  <a href="#aa596605832739ec4ab5ec33f7a0e6dba">More...</a><br /></td></tr>
<tr class="separator:aa596605832739ec4ab5ec33f7a0e6dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53ecbc5ef1904ccd4ff60686ec20ecc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae53ecbc5ef1904ccd4ff60686ec20ecc"></a>
const sf::Texture &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxy_1_1_multi_render_texture.html#ae53ecbc5ef1904ccd4ff60686ec20ecc">getDepthTexture</a> () const </td></tr>
<tr class="memdesc:ae53ecbc5ef1904ccd4ff60686ec20ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the depth texture if this MRT was created with one <br /></td></tr>
<tr class="separator:ae53ecbc5ef1904ccd4ff60686ec20ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An off-screen render target which can draw on multiple textures at once. </p>
<p>An SFML-compatible render target, the <a class="el" href="classxy_1_1_multi_render_texture.html" title="An off-screen render target which can draw on multiple textures at once. ">MultiRenderTexture</a> class allows a single draw call to draw to multiple textures at once. This is useful for cases such as deferred rendering where diffuse/normal/specular data for a scene may be drawn to separate textures before blending in a single shader. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a07638210764610825e23a7ba3fa98821"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MultiRenderTexture::create </td>
          <td>(</td>
          <td class="paramtype">sf::Uint32&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sf::Uint32&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sf::Uint32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>depthbuffer</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>depthTexture</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the <a class="el" href="classxy_1_1_multi_render_texture.html" title="An off-screen render target which can draw on multiple textures at once. ">MultiRenderTexture</a>. By default MRTs are empty and invalid and this function must first be called before the MRT can be used. Currently all of the textures created in the MRT have the same parameter, width, height, colour depth etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>Width of the render target in pixels </td></tr>
    <tr><td class="paramname">height</td><td>Height of the render target in pixels </td></tr>
    <tr><td class="paramname">count</td><td>Number of textures to create. Currently the max supported is 4 </td></tr>
    <tr><td class="paramname">depthbuffer</td><td>Set to true if you want to create a depth buffer with the target. This is false by default as it is the most common use case. </td></tr>
    <tr><td class="paramname">depthTexture</td><td>If this is true a depth texture is created (assuming depthbuffer is also true) which can be used for rendering depth values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if creation is successful </dd></dl>

</div>
</div>
<a class="anchor" id="aa596605832739ec4ab5ec33f7a0e6dba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const sf::Texture &amp; MultiRenderTexture::getTexture </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a read-only reference to the texture at the given index. Once the MRT has been drawn on and updated a texture can be retrieved and used with a sf::Sprite for example, or as a uniform parameter of a shader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the texture to retrieve. This must be lower than the number of textures requested when crea() was called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2411aed316ecd06e6124d40c358809d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MultiRenderTexture::setActive </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>active</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Activate or deactivate the MRT for rendering. </p>
<dl class="section return"><dt>Returns</dt><dd>True if successful. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
